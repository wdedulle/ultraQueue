; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\xback\Documents\Visual Studio 2010\Projects\Buffers\Buffers\UltraQueue.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?CreateQueue@Buffers@@AAEHI@Z			; Buffers::CreateQueue
PUBLIC	??_7Buffers@@6B@				; Buffers::`vftable'
PUBLIC	??0Buffers@@QAE@III@Z				; Buffers::Buffers
PUBLIC	??_R4Buffers@@6B@				; Buffers::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVBuffers@@@8				; Buffers `RTTI Type Descriptor'
PUBLIC	??_R3Buffers@@8					; Buffers::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Buffers@@8					; Buffers::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Buffers@@8			; Buffers::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp__InitializeCriticalSectionAndSpinCount@8:PROC
EXTRN	?CheckCPUFeature@@YAHI@Z:PROC			; CheckCPUFeature
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_EBuffers@@UAEPAXI@Z:PROC			; Buffers::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@Buffers@@8
; File c:\users\xback\documents\visual studio 2010\projects\buffers\buffers\ultraqueue.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@Buffers@@8 DD FLAT:??_R0?AVBuffers@@@8	; Buffers::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Buffers@@8
rdata$r	ENDS
;	COMDAT ??_R2Buffers@@8
rdata$r	SEGMENT
??_R2Buffers@@8 DD FLAT:??_R1A@?0A@EA@Buffers@@8	; Buffers::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Buffers@@8
rdata$r	SEGMENT
??_R3Buffers@@8 DD 00H					; Buffers::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Buffers@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBuffers@@@8
_DATA	SEGMENT
??_R0?AVBuffers@@@8 DD FLAT:??_7type_info@@6B@		; Buffers `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBuffers@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Buffers@@6B@
rdata$r	SEGMENT
??_R4Buffers@@6B@ DD 00H				; Buffers::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBuffers@@@8
	DD	FLAT:??_R3Buffers@@8
rdata$r	ENDS
;	COMDAT ??_7Buffers@@6B@
CONST	SEGMENT
??_7Buffers@@6B@ DD FLAT:??_R4Buffers@@6B@		; Buffers::`vftable'
	DD	FLAT:??_EBuffers@@UAEPAXI@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0Buffers@@QAE@III@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__NrPtrs$ = 8						; size = 4
__size$ = 12						; size = 4
__BufferType$ = 16					; size = 4
??0Buffers@@QAE@III@Z PROC				; Buffers::Buffers, COMDAT
; _this$ = ecx

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Buffers@@6B@

; 84   : 	this->size = _size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 85   : 	this->QueueError = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+16], 0

; 86   : 	this->CreateQueue(_size);

	mov	eax, DWORD PTR __size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateQueue@Buffers@@AAEHI@Z		; Buffers::CreateQueue

; 87   : 	this->WrPtr = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 88   : 	this->BufferType = _BufferType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __BufferType$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 89   : 	this->NrPtrs = _NrPtrs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __NrPtrs$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 90   : 	this->OverFlow = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 91   : 
; 92   : 	memset(&this->RdPtr[0], 0, _NrPtrs*sizeof (unsigned int));

	mov	eax, DWORD PTR __NrPtrs$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 93   : 	memset(&this->QLoad[0], 0, _NrPtrs*sizeof (unsigned int));

	mov	eax, DWORD PTR __NrPtrs$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 592				; 00000250H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 94   : 
; 95   : 	//Calculate SSE2 counter
; 96   : 	this->Amount_SSE2_Operations = _NrPtrs + (4 - (_NrPtrs % 4));

	mov	eax, DWORD PTR __NrPtrs$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	add	eax, DWORD PTR __NrPtrs$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 97   : 		
; 98   : 	if (CheckCPUFeature(2) == 1) this->SSE2_Present = true;

	push	2
	call	?CheckCPUFeature@@YAHI@Z		; CheckCPUFeature
	add	esp, 4
	cmp	eax, 1
	jne	SHORT $LN4@Buffers
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+72], 1
	jmp	SHORT $LN3@Buffers
$LN4@Buffers:

; 99   : 	else this->SSE2_Present = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+72], 0
$LN3@Buffers:

; 100  : 
; 101  : 	if (CheckCPUFeature(11) > 2)

	push	11					; 0000000bH
	call	?CheckCPUFeature@@YAHI@Z		; CheckCPUFeature
	add	esp, 4
	cmp	eax, 2
	jle	SHORT $LN2@Buffers

; 102  : 	{	 // Tripple Core & higher
; 103  : 		InitializeCriticalSectionAndSpinCount(&this->Crit1, 0x0000005F);	// 95 Spin is added (benchmarked using Vtune) so a thread does not use an expensive Sleep while the 

	push	95					; 0000005fH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8

; 104  : 	}																// chance is high it will be able to continue within a few cycles
; 105  : 	else															// This improves the speed dramatically on very small Threaded Reads or Writes (<64 Bytes)

	jmp	SHORT $LN5@Buffers
$LN2@Buffers:

; 106  : 	{	// Single or Dual Core
; 107  : 		InitializeCriticalSectionAndSpinCount(&this->Crit1, 0x00000000);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8
$LN5@Buffers:

; 108  : 	}
; 109  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Buffers@@QAE@III@Z ENDP				; Buffers::Buffers
_TEXT	ENDS
PUBLIC	??1Buffers@@UAE@XZ				; Buffers::~Buffers
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GBuffers@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GBuffers@@UAEPAXI@Z PROC				; Buffers::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Buffers@@UAE@XZ			; Buffers::~Buffers
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GBuffers@@UAEPAXI@Z ENDP				; Buffers::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp__DeleteCriticalSection@4:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ??1Buffers@@UAE@XZ
_TEXT	SEGMENT
$T30665 = -72						; size = 4
_this$ = -4						; size = 4
??1Buffers@@UAE@XZ PROC					; Buffers::~Buffers, COMDAT
; _this$ = ecx

; 113  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Buffers@@6B@

; 114  : 	DeleteCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 115  : #ifdef __ALIGNED__
; 116  : 	if (this->CQ) _mm_free(this->CQ);
; 117  : #else
; 118  : 	if (this->CQ) delete []this->CQ;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN1@Buffers@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR $T30665[ebp], ecx
	mov	edx, DWORD PTR $T30665[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Buffers@2:

; 119  : #endif
; 120  : 	this->CQ = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 121  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1Buffers@@UAE@XZ ENDP					; Buffers::~Buffers
_TEXT	ENDS
PUBLIC	?QFree@Buffers@@QAEII@Z				; Buffers::QFree
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ?QFree@Buffers@@QAEII@Z
_TEXT	SEGMENT
_k$ = -8						; size = 4
_this$ = -4						; size = 4
_NrPtr$ = 8						; size = 4
?QFree@Buffers@@QAEII@Z PROC				; Buffers::QFree, COMDAT
; _this$ = ecx

; 125  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 126  : 	unsigned int k=0;

	mov	DWORD PTR _k$[ebp], 0

; 127  : 
; 128  : 	if (NrPtr >= this->NrPtrs) return 0;	// Invalid pointer

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _NrPtr$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jb	SHORT $LN1@QFree
	xor	eax, eax
	jmp	SHORT $LN2@QFree
$LN1@QFree:

; 129  : 
; 130  : 	EnterCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__EnterCriticalSection@4

; 131  : 		k = (this->size - this->QLoad[NrPtr]); // k is needed to give the function a chance to release the lock first before returning

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _NrPtr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+ecx*4+592]
	mov	DWORD PTR _k$[ebp], eax

; 132  : 	LeaveCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 133  : 	
; 134  : 	return k;

	mov	eax, DWORD PTR _k$[ebp]
$LN2@QFree:

; 135  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?QFree@Buffers@@QAEII@Z ENDP				; Buffers::QFree
_TEXT	ENDS
PUBLIC	?QLoaded@Buffers@@QAEII@Z			; Buffers::QLoaded
; Function compile flags: /Odtp /ZI
;	COMDAT ?QLoaded@Buffers@@QAEII@Z
_TEXT	SEGMENT
_k$ = -8						; size = 4
_this$ = -4						; size = 4
_NrPtr$ = 8						; size = 4
?QLoaded@Buffers@@QAEII@Z PROC				; Buffers::QLoaded, COMDAT
; _this$ = ecx

; 138  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 139  : 	unsigned int k=0;

	mov	DWORD PTR _k$[ebp], 0

; 140  : 
; 141  : 	if (NrPtr >= this->NrPtrs) return 0;	// Invalid pointer

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _NrPtr$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jb	SHORT $LN1@QLoaded
	xor	eax, eax
	jmp	SHORT $LN2@QLoaded
$LN1@QLoaded:

; 142  : 
; 143  : 	EnterCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__EnterCriticalSection@4

; 144  : 		k = this->QLoad[NrPtr];	

	mov	eax, DWORD PTR _NrPtr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+592]
	mov	DWORD PTR _k$[ebp], edx

; 145  : 	LeaveCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 146  : 	
; 147  : 	return k;

	mov	eax, DWORD PTR _k$[ebp]
$LN2@QLoaded:

; 148  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?QLoaded@Buffers@@QAEII@Z ENDP				; Buffers::QLoaded
_TEXT	ENDS
PUBLIC	?Flush@Buffers@@QAEXH@Z				; Buffers::Flush
; Function compile flags: /Odtp /ZI
;	COMDAT ?Flush@Buffers@@QAEXH@Z
_TEXT	SEGMENT
_i$30347 = -16						; size = 4
_CacheCopy_WrPtr$30346 = -12				; size = 4
_CacheCopy_NrPtrs$30345 = -8				; size = 4
_this$ = -4						; size = 4
_NrPtr$ = 8						; size = 4
?Flush@Buffers@@QAEXH@Z PROC				; Buffers::Flush, COMDAT
; _this$ = ecx

; 151  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 	if (NrPtr >= (int)this->NrPtrs) return;	// Invalid pointer

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _NrPtr$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jl	SHORT $LN6@Flush
	jmp	$LN7@Flush
$LN6@Flush:

; 153  : 
; 154  : 	EnterCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__EnterCriticalSection@4

; 155  : 	if (NrPtr == -1)	// If -1 is received, reset all pointers

	cmp	DWORD PTR _NrPtr$[ebp], -1
	jne	SHORT $LN5@Flush

; 156  : 		{
; 157  : 			const unsigned int CacheCopy_NrPtrs = this->NrPtrs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _CacheCopy_NrPtrs$30345[ebp], ecx

; 158  : 			unsigned int CacheCopy_WrPtr = this->WrPtr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _CacheCopy_WrPtr$30346[ebp], ecx

; 159  : 
; 160  : 			for (unsigned int i=0;i<CacheCopy_NrPtrs;++i)

	mov	DWORD PTR _i$30347[ebp], 0
	jmp	SHORT $LN4@Flush
$LN3@Flush:
	mov	eax, DWORD PTR _i$30347[ebp]
	add	eax, 1
	mov	DWORD PTR _i$30347[ebp], eax
$LN4@Flush:
	mov	eax, DWORD PTR _i$30347[ebp]
	cmp	eax, DWORD PTR _CacheCopy_NrPtrs$30345[ebp]
	jae	SHORT $LN2@Flush

; 161  : 			{
; 162  : 				this->RdPtr[i] = CacheCopy_WrPtr;

	mov	eax, DWORD PTR _i$30347[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _CacheCopy_WrPtr$30346[ebp]
	mov	DWORD PTR [ecx+eax*4+80], edx

; 163  : 			}

	jmp	SHORT $LN3@Flush
$LN2@Flush:

; 164  : 
; 165  : 			memset(&this->QLoad[0],0, this->NrPtrs * sizeof (unsigned int));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	shl	ecx, 2
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 592				; 00000250H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 166  : 
; 167  : 		}
; 168  : 	else

	jmp	SHORT $LN1@Flush
$LN5@Flush:

; 169  : 		{
; 170  : 			this->RdPtr[NrPtr]=this->WrPtr;

	mov	eax, DWORD PTR _NrPtr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+eax*4+80], edx

; 171  : 			this->QLoad[NrPtr] = 0;

	mov	eax, DWORD PTR _NrPtr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+592], 0
$LN1@Flush:

; 172  : 		}
; 173  : 		
; 174  : 	LeaveCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4
$LN7@Flush:

; 175  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Flush@Buffers@@QAEXH@Z ENDP				; Buffers::Flush
_TEXT	ENDS
PUBLIC	__TI1H
PUBLIC	__CTA1H
PUBLIC	__CT??_R0H@84
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
;	COMDAT ??_R0H@8
_DATA	SEGMENT
??_R0H@8 DD	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DD	00H
	DB	'.H', 00H
_DATA	ENDS
;	COMDAT __CT??_R0H@84
xdata$x	SEGMENT
__CT??_R0H@84 DD 01H
	DD	FLAT:??_R0H@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CTA1H
xdata$x	SEGMENT
__CTA1H	DD	01H
	DD	FLAT:__CT??_R0H@84
xdata$x	ENDS
;	COMDAT __TI1H
xdata$x	SEGMENT
__TI1H	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?CreateQueue@Buffers@@AAEHI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?CreateQueue@Buffers@@AAEHI@Z$0
__unwindtable$?CreateQueue@Buffers@@AAEHI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?CreateQueue@Buffers@@AAEHI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?CreateQueue@Buffers@@AAEHI@Z$2
__ehfuncinfo$?CreateQueue@Buffers@@AAEHI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CreateQueue@Buffers@@AAEHI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?CreateQueue@Buffers@@AAEHI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?CreateQueue@Buffers@@AAEHI@Z
_TEXT	SEGMENT
tv74 = -100						; size = 4
$T30674 = -96						; size = 4
$T30675 = -92						; size = 4
$T30677 = -88						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_size$ = 8						; size = 4
?CreateQueue@Buffers@@AAEHI@Z PROC			; Buffers::CreateQueue, COMDAT
; _this$ = ecx

; 178  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateQueue@Buffers@@AAEHI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 179  : #ifdef __ALIGNED__
; 180  : 	this->CQ = (unsigned char*) _mm_malloc(size,64);
; 181  : 	if (!this->CQ) return -1;
; 182  : #else
; 183  : 	try
; 184  : 	{

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 185  : 		this->CQ = new unsigned char[size];

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv74[ebp], eax
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T30674[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T30674[ebp]
	mov	DWORD PTR [edx+68], eax

; 186  : 		if (!this->CQ) throw -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+68], 0
	jne	SHORT $LN1@CreateQueu
	mov	DWORD PTR $T30675[ebp], -1
	push	OFFSET __TI1H
	lea	eax, DWORD PTR $T30675[ebp]
	push	eax
	call	__CxxThrowException@8
$LN1@CreateQueu:

; 187  : 	}

	jmp	SHORT $LN5@CreateQueu
__catch$?CreateQueue@Buffers@@AAEHI@Z$0:

; 188  : 
; 189  : 	catch (...)
; 190  : 	{
; 191  : 		this->CQ = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 192  : 		this->QueueError = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+16], 1

; 193  : 		return -1;

	mov	DWORD PTR $T30677[ebp], -1
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN8@CreateQueu
	ret	0

; 194  : 	}

	mov	eax, $LN5@CreateQueu
	ret	0
$LN5@CreateQueu:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN7@CreateQueu
$LN8@CreateQueu:

; 193  : 		return -1;

	mov	eax, DWORD PTR $T30677[ebp]
	jmp	SHORT $LN4@CreateQueu
$LN7@CreateQueu:

; 195  : #endif
; 196  : 	return 0;

	xor	eax, eax
$LN4@CreateQueu:

; 197  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?CreateQueue@Buffers@@AAEHI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CreateQueue@Buffers@@AAEHI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateQueue@Buffers@@AAEHI@Z ENDP			; Buffers::CreateQueue
PUBLIC	?Read@Buffers@@QAEHIIPAE@Z			; Buffers::Read
EXTRN	_A_memcpy:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ?Read@Buffers@@QAEHIIPAE@Z
_TEXT	SEGMENT
_i$30391 = -32						; size = 4
_Small$30389 = -28					; size = 4
_temp_QLoad$ = -24					; size = 4
_temp_RdPtr$ = -20					; size = 4
_offset$ = -16						; size = 4
_block$ = -12						; size = 4
_temp_size$ = -8					; size = 4
_this$ = -4						; size = 4
_NrPtr$ = 8						; size = 4
_r$ = 12						; size = 4
_d$ = 16						; size = 4
?Read@Buffers@@QAEHIIPAE@Z PROC				; Buffers::Read, COMDAT
; _this$ = ecx

; 200  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 201  : 	if (NrPtr >= this->NrPtrs) return -1;	// Invalid pointer

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _NrPtr$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jb	SHORT $LN17@Read
	or	eax, -1
	jmp	$LN18@Read
$LN17@Read:

; 202  : 
; 203  : 	if (!r) return -2;	// A minimum of 1 byte should be requested

	cmp	DWORD PTR _r$[ebp], 0
	jne	SHORT $LN16@Read
	mov	eax, -2					; fffffffeH
	jmp	$LN18@Read
$LN16@Read:

; 204  : 
; 205  : 	EnterCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__EnterCriticalSection@4

; 206  : 
; 207  : 	if (!this->QLoad[NrPtr])

	mov	eax, DWORD PTR _NrPtr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+592], 0
	jne	SHORT $LN15@Read

; 208  : 		{
; 209  : 			LeaveCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 210  : 			return -3;	//Queue is empty

	mov	eax, -3					; fffffffdH
	jmp	$LN18@Read
$LN15@Read:

; 211  : 		}
; 212  : 	if (r > this->QLoad[NrPtr])

	mov	eax, DWORD PTR _NrPtr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _r$[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4+592]
	jbe	SHORT $LN14@Read

; 213  : 		{
; 214  : 			LeaveCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 215  : 			return -4;	//Requested amount of bytes is higher than nr of available bytes

	mov	eax, -4					; fffffffcH
	jmp	$LN18@Read
$LN14@Read:

; 216  : 		}
; 217  : 	
; 218  : 	//copy class vars to locals for caching reasons (96% Speed increase)
; 219  : 	const unsigned int temp_size = this->size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _temp_size$[ebp], ecx

; 220  : 	unsigned int block;	//Space to Wrap point
; 221  : 	unsigned int offset=0;	//Unfinished block indicator + starting point indicator

	mov	DWORD PTR _offset$[ebp], 0

; 222  : 	unsigned int temp_RdPtr = this->RdPtr[NrPtr];

	mov	eax, DWORD PTR _NrPtr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+80]
	mov	DWORD PTR _temp_RdPtr$[ebp], edx

; 223  : 	unsigned int temp_QLoad = this->QLoad[NrPtr];

	mov	eax, DWORD PTR _NrPtr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+592]
	mov	DWORD PTR _temp_QLoad$[ebp], edx
$LN13@Read:

; 224  : 
; 225  : 	//read from buff
; 226  : 	while(r)	// Loop until all bytes have been read

	cmp	DWORD PTR _r$[ebp], 0
	je	$LN12@Read

; 227  : 	{
; 228  : 		block = temp_size - (temp_RdPtr+1);	// Get distance to Wrap point

	mov	eax, DWORD PTR _temp_RdPtr$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _temp_size$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _block$[ebp], ecx

; 229  : 
; 230  : 		if (r <= BLOCKSIZE_READ || block <= BLOCKSIZE_READ)	// Byte-by-Byte Read

	cmp	DWORD PTR _r$[ebp], 8
	jbe	SHORT $LN10@Read
	cmp	DWORD PTR _block$[ebp], 8
	ja	$LN11@Read
$LN10@Read:

; 231  : 		{	// When not much data to write, or we're close at the wrap point, write byte-per-byte
; 232  : 			unsigned int Small = r;

	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR _Small$30389[ebp], eax

; 233  : 
; 234  : 			if (Small > BLOCKSIZE_READ && (Small-block) > BLOCKSIZE_READ) Small = block+1;

	cmp	DWORD PTR _Small$30389[ebp], 8
	jbe	SHORT $LN9@Read
	mov	eax, DWORD PTR _Small$30389[ebp]
	sub	eax, DWORD PTR _block$[ebp]
	cmp	eax, 8
	jbe	SHORT $LN9@Read
	mov	eax, DWORD PTR _block$[ebp]
	add	eax, 1
	mov	DWORD PTR _Small$30389[ebp], eax
$LN9@Read:

; 235  : 			//If the reason for BbB is "Close at Wrap", read just behind the wrap & re-evaluate if we can blockread again
; 236  : 			
; 237  : 			for (unsigned int i=0;i<Small;++i)

	mov	DWORD PTR _i$30391[ebp], 0
	jmp	SHORT $LN8@Read
$LN7@Read:
	mov	eax, DWORD PTR _i$30391[ebp]
	add	eax, 1
	mov	DWORD PTR _i$30391[ebp], eax
$LN8@Read:
	mov	eax, DWORD PTR _i$30391[ebp]
	cmp	eax, DWORD PTR _Small$30389[ebp]
	jae	SHORT $LN6@Read

; 238  : 			{
; 239  : 				++temp_RdPtr;

	mov	eax, DWORD PTR _temp_RdPtr$[ebp]
	add	eax, 1
	mov	DWORD PTR _temp_RdPtr$[ebp], eax

; 240  : 				if (temp_RdPtr == temp_size) temp_RdPtr = 0;	// Make it circular

	mov	eax, DWORD PTR _temp_RdPtr$[ebp]
	cmp	eax, DWORD PTR _temp_size$[ebp]
	jne	SHORT $LN5@Read
	mov	DWORD PTR _temp_RdPtr$[ebp], 0
$LN5@Read:

; 241  : 				d[i+offset] = this->CQ[temp_RdPtr];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	edx, DWORD PTR _i$30391[ebp]
	add	edx, DWORD PTR _offset$[ebp]
	mov	eax, DWORD PTR _d$[ebp]
	mov	esi, DWORD PTR _temp_RdPtr$[ebp]
	mov	cl, BYTE PTR [ecx+esi]
	mov	BYTE PTR [eax+edx], cl

; 242  : 				--r;

	mov	eax, DWORD PTR _r$[ebp]
	sub	eax, 1
	mov	DWORD PTR _r$[ebp], eax

; 243  : 				--temp_QLoad;

	mov	eax, DWORD PTR _temp_QLoad$[ebp]
	sub	eax, 1
	mov	DWORD PTR _temp_QLoad$[ebp], eax

; 244  : 			}

	jmp	SHORT $LN7@Read
$LN6@Read:

; 245  : 		}
; 246  : 		else	// Block Read		Max block read = size of requested bytes (if possible)

	jmp	SHORT $LN4@Read
$LN11@Read:

; 247  : 		{
; 248  : 			if (block > r) block = r;	// If more sequential space is available than requested amount, write amount left

	mov	eax, DWORD PTR _block$[ebp]
	cmp	eax, DWORD PTR _r$[ebp]
	jbe	SHORT $LN3@Read
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR _block$[ebp], eax
$LN3@Read:

; 249  : 			if (block >= 4096)

	cmp	DWORD PTR _block$[ebp], 4096		; 00001000H
	jb	SHORT $LN2@Read

; 250  : 			{
; 251  : 				memcpy(d,&this->CQ[temp_RdPtr+1],block);	//Microsoft memcpy is faster >4k blocks

	mov	eax, DWORD PTR _block$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _temp_RdPtr$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]
	push	ecx
	mov	edx, DWORD PTR _d$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 252  : 			}
; 253  : 			else

	jmp	SHORT $LN1@Read
$LN2@Read:

; 254  : 			{
; 255  : 				A_memcpy(d,&this->CQ[temp_RdPtr+1],block);	//Agner Fog's lib is !A LOT! faster <4k blocks

	mov	eax, DWORD PTR _block$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _temp_RdPtr$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]
	push	ecx
	mov	edx, DWORD PTR _d$[ebp]
	push	edx
	call	_A_memcpy
	add	esp, 12					; 0000000cH
$LN1@Read:

; 256  : 			}
; 257  : 			temp_RdPtr += block;

	mov	eax, DWORD PTR _temp_RdPtr$[ebp]
	add	eax, DWORD PTR _block$[ebp]
	mov	DWORD PTR _temp_RdPtr$[ebp], eax

; 258  : 			temp_QLoad -=block;

	mov	eax, DWORD PTR _temp_QLoad$[ebp]
	sub	eax, DWORD PTR _block$[ebp]
	mov	DWORD PTR _temp_QLoad$[ebp], eax

; 259  : 			r -= block;	// Decrease nr of BytesToRead

	mov	eax, DWORD PTR _r$[ebp]
	sub	eax, DWORD PTR _block$[ebp]
	mov	DWORD PTR _r$[ebp], eax

; 260  : 			offset = block;	// offset = position to start for the Wrap write

	mov	eax, DWORD PTR _block$[ebp]
	mov	DWORD PTR _offset$[ebp], eax
$LN4@Read:

; 261  : 		}
; 262  : 	}

	jmp	$LN13@Read
$LN12@Read:

; 263  : 
; 264  : 	//Save changes
; 265  : 	this->RdPtr[NrPtr] = temp_RdPtr;

	mov	eax, DWORD PTR _NrPtr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _temp_RdPtr$[ebp]
	mov	DWORD PTR [ecx+eax*4+80], edx

; 266  : 	this->QLoad[NrPtr] = temp_QLoad;

	mov	eax, DWORD PTR _NrPtr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _temp_QLoad$[ebp]
	mov	DWORD PTR [ecx+eax*4+592], edx

; 267  : 
; 268  : 	LeaveCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 269  : 
; 270  : 	return 0;

	xor	eax, eax
$LN18@Read:

; 271  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Read@Buffers@@QAEHIIPAE@Z ENDP				; Buffers::Read
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?Write@Buffers@@QAEHIPAE@Z			; Buffers::Write
; Function compile flags: /Odtp /ZI
;	COMDAT ?Write@Buffers@@QAEHIPAE@Z
_TEXT	SEGMENT
$T30448 = -1264						; size = 16
$T30449 = -1248						; size = 16
$T30484 = -1232						; size = 16
$T30485 = -1216						; size = 16
_q$30492 = -1132					; size = 4
_CacheCopy_OverFlow$30491 = -1128			; size = 4
_q$30487 = -1124					; size = 4
_q$30477 = -1120					; size = 4
_SSEops$30476 = -1116					; size = 4
_i$30466 = -1112					; size = 4
_Small$30464 = -1108					; size = 4
_w2$30458 = -1104					; size = 4
_offset$30457 = -1100					; size = 4
_block$30456 = -1096					; size = 4
_q$30451 = -1092					; size = 4
_q$30441 = -1088					; size = 4
_SSEops$30440 = -1084					; size = 4
_i$30430 = -1080					; size = 4
_Small$30428 = -1076					; size = 4
_w2$30422 = -1072					; size = 4
_offset$30421 = -1068					; size = 4
_block$30420 = -1064					; size = 4
_i$30414 = -1060					; size = 4
_temp_RdPtr$ = -1056					; size = 512
_temp_QLoad$ = -544					; size = 512
_temp_WrPtr$ = -20					; size = 4
_temp_NrPtrs$ = -16					; size = 4
_temp_size$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_w$ = 8							; size = 4
_d$ = 12						; size = 4
?Write@Buffers@@QAEHIPAE@Z PROC				; Buffers::Write, COMDAT
; _this$ = ecx

; 274  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 1272				; 000004f8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 275  : 	if (!w) return -1;	// A minimum of 1 byte should be requested

	cmp	DWORD PTR _w$[ebx], 0
	jne	SHORT $LN54@Write
	or	eax, -1
	jmp	$LN55@Write
$LN54@Write:

; 276  : 	EnterCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__EnterCriticalSection@4

; 277  : 	
; 278  : 	//Copy class vars to local vars for caching purposes (~ +95% speed increase)
; 279  : 	
; 280  : 	const unsigned int temp_size = this->size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _temp_size$[ebp], ecx

; 281  : 	const unsigned int temp_NrPtrs = this->NrPtrs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _temp_NrPtrs$[ebp], ecx

; 282  : 	unsigned int temp_WrPtr = this->WrPtr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _temp_WrPtr$[ebp], ecx

; 283  : 	__declspec (align(16)) unsigned int temp_QLoad[MAXPTRS];
; 284  : 	__declspec (align(16)) unsigned int temp_RdPtr[MAXPTRS];
; 285  : 	
; 286  : 	A_memcpy(&temp_QLoad[0],&this->QLoad[0],temp_NrPtrs*sizeof (unsigned int));

	mov	eax, DWORD PTR _temp_NrPtrs$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 592				; 00000250H
	push	ecx
	lea	edx, DWORD PTR _temp_QLoad$[ebp]
	push	edx
	call	_A_memcpy
	add	esp, 12					; 0000000cH

; 287  : 	A_memcpy(&temp_RdPtr[0],&this->RdPtr[0],temp_NrPtrs*sizeof (unsigned int));

	mov	eax, DWORD PTR _temp_NrPtrs$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	lea	edx, DWORD PTR _temp_RdPtr$[ebp]
	push	edx
	call	_A_memcpy
	add	esp, 12					; 0000000cH

; 288  : 
; 289  : 	//Buffer write actions
; 290  : 
; 291  : 	if (this->BufferType == RING)	//ringbuffer

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 1
	jne	$LN53@Write

; 292  : 	{
; 293  : 		for (unsigned int i=0;i<temp_NrPtrs;++i)	//check space requirements

	mov	DWORD PTR _i$30414[ebp], 0
	jmp	SHORT $LN52@Write
$LN51@Write:
	mov	eax, DWORD PTR _i$30414[ebp]
	add	eax, 1
	mov	DWORD PTR _i$30414[ebp], eax
$LN52@Write:
	mov	eax, DWORD PTR _i$30414[ebp]
	cmp	eax, DWORD PTR _temp_NrPtrs$[ebp]
	jae	SHORT $LN50@Write

; 294  : 		{
; 295  : 			if(temp_QLoad[i] >= temp_size)

	mov	eax, DWORD PTR _i$30414[ebp]
	mov	ecx, DWORD PTR _temp_QLoad$[ebp+eax*4]
	cmp	ecx, DWORD PTR _temp_size$[ebp]
	jb	SHORT $LN49@Write

; 296  : 				{
; 297  : 					this->OverFlow = 1;	// Set flag to inform that a write action could not be performed

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 1

; 298  : 					LeaveCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 299  : 					return -2;	// One of the Ring buffers is completely full

	mov	eax, -2					; fffffffeH
	jmp	$LN55@Write
$LN49@Write:

; 300  : 				}
; 301  : 			if (w > (temp_size - temp_QLoad[i]))

	mov	eax, DWORD PTR _i$30414[ebp]
	mov	ecx, DWORD PTR _temp_size$[ebp]
	sub	ecx, DWORD PTR _temp_QLoad$[ebp+eax*4]
	cmp	DWORD PTR _w$[ebx], ecx
	jbe	SHORT $LN48@Write

; 302  : 				{
; 303  : 					this->OverFlow = 1;	// Set flag to inform that a write action could not be performed

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 1

; 304  : 					LeaveCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 305  : 					return -3;	// One of the Ring buffers lacks space to write all requested bytes

	mov	eax, -3					; fffffffdH
	jmp	$LN55@Write
$LN48@Write:

; 306  : 				}
; 307  : 		}

	jmp	$LN51@Write
$LN50@Write:

; 308  : 
; 309  : 		unsigned int block;
; 310  : 		unsigned int offset=0;

	mov	DWORD PTR _offset$30421[ebp], 0

; 311  : 		unsigned int w2 = w;	// Keep a copy of written bytes to update Read pointer(s) & Load(s)

	mov	eax, DWORD PTR _w$[ebx]
	mov	DWORD PTR _w2$30422[ebp], eax
$LN47@Write:

; 312  : 
; 313  : 		while (w2)

	cmp	DWORD PTR _w2$30422[ebp], 0
	je	$LN46@Write

; 314  : 		{
; 315  : 			block = temp_size - (temp_WrPtr+1);	// Get distance to Wrap point

	mov	eax, DWORD PTR _temp_WrPtr$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _temp_size$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _block$30420[ebp], ecx

; 316  : 
; 317  : 			if (w2 <= BLOCKSIZE_WRITE || block <= BLOCKSIZE_WRITE)	// Byte-by-Byte Read

	cmp	DWORD PTR _w2$30422[ebp], 8
	jbe	SHORT $LN44@Write
	cmp	DWORD PTR _block$30420[ebp], 8
	ja	$LN45@Write
$LN44@Write:

; 318  : 			{	// When not much data to write, or we're close at the wrap point, write byte-per-byte
; 319  : 				unsigned int Small = w2;

	mov	eax, DWORD PTR _w2$30422[ebp]
	mov	DWORD PTR _Small$30428[ebp], eax

; 320  : 
; 321  : 				if (Small > BLOCKSIZE_WRITE && (Small-block) > BLOCKSIZE_WRITE) Small = block+1;

	cmp	DWORD PTR _Small$30428[ebp], 8
	jbe	SHORT $LN43@Write
	mov	eax, DWORD PTR _Small$30428[ebp]
	sub	eax, DWORD PTR _block$30420[ebp]
	cmp	eax, 8
	jbe	SHORT $LN43@Write
	mov	eax, DWORD PTR _block$30420[ebp]
	add	eax, 1
	mov	DWORD PTR _Small$30428[ebp], eax
$LN43@Write:

; 322  : 
; 323  : 				for (unsigned int i=0;i<Small;++i)

	mov	DWORD PTR _i$30430[ebp], 0
	jmp	SHORT $LN42@Write
$LN41@Write:
	mov	eax, DWORD PTR _i$30430[ebp]
	add	eax, 1
	mov	DWORD PTR _i$30430[ebp], eax
$LN42@Write:
	mov	eax, DWORD PTR _i$30430[ebp]
	cmp	eax, DWORD PTR _Small$30428[ebp]
	jae	SHORT $LN40@Write

; 324  : 				{
; 325  : 					++temp_WrPtr;

	mov	eax, DWORD PTR _temp_WrPtr$[ebp]
	add	eax, 1
	mov	DWORD PTR _temp_WrPtr$[ebp], eax

; 326  : 					if (temp_WrPtr == temp_size) temp_WrPtr = 0;	// inc + compare&set is 40% faster than modulus trick

	mov	eax, DWORD PTR _temp_WrPtr$[ebp]
	cmp	eax, DWORD PTR _temp_size$[ebp]
	jne	SHORT $LN39@Write
	mov	DWORD PTR _temp_WrPtr$[ebp], 0
$LN39@Write:

; 327  : 					this->CQ[temp_WrPtr] = d[i+offset];

	mov	eax, DWORD PTR _i$30430[ebp]
	add	eax, DWORD PTR _offset$30421[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	ecx, DWORD PTR _temp_WrPtr$[ebp]
	mov	esi, DWORD PTR _d$[ebx]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al

; 328  : 					--w2; //Decrease amount to write

	mov	eax, DWORD PTR _w2$30422[ebp]
	sub	eax, 1
	mov	DWORD PTR _w2$30422[ebp], eax

; 329  : 				}

	jmp	SHORT $LN41@Write
$LN40@Write:

; 330  : 			}
; 331  : 			else	// Block Write		Max block write = size of requested bytes (if possible)

	jmp	$LN38@Write
$LN45@Write:

; 332  : 			{
; 333  : 				if (block > w2) block = w2;	// If more sequential space is available than requested amount, write requested amount (otherwise we have a memory (& pointer) overflow

	mov	eax, DWORD PTR _block$30420[ebp]
	cmp	eax, DWORD PTR _w2$30422[ebp]
	jbe	SHORT $LN37@Write
	mov	eax, DWORD PTR _w2$30422[ebp]
	mov	DWORD PTR _block$30420[ebp], eax
$LN37@Write:

; 334  : 				if (block >= 4096)

	cmp	DWORD PTR _block$30420[ebp], 4096	; 00001000H
	jb	SHORT $LN36@Write

; 335  : 				{
; 336  : 					memcpy(&this->CQ[temp_WrPtr+1],d,block);

	mov	eax, DWORD PTR _block$30420[ebp]
	push	eax
	mov	ecx, DWORD PTR _d$[ebx]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	ecx, DWORD PTR _temp_WrPtr$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 337  : 				}
; 338  : 				else

	jmp	SHORT $LN35@Write
$LN36@Write:

; 339  : 				{
; 340  : 					A_memcpy(&this->CQ[temp_WrPtr+1],d,block);

	mov	eax, DWORD PTR _block$30420[ebp]
	push	eax
	mov	ecx, DWORD PTR _d$[ebx]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	ecx, DWORD PTR _temp_WrPtr$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	call	_A_memcpy
	add	esp, 12					; 0000000cH
$LN35@Write:

; 341  : 				}
; 342  : 				temp_WrPtr += block;

	mov	eax, DWORD PTR _temp_WrPtr$[ebp]
	add	eax, DWORD PTR _block$30420[ebp]
	mov	DWORD PTR _temp_WrPtr$[ebp], eax

; 343  : 				w2 -= block;	// Decrease nr of BytesToWrite

	mov	eax, DWORD PTR _w2$30422[ebp]
	sub	eax, DWORD PTR _block$30420[ebp]
	mov	DWORD PTR _w2$30422[ebp], eax

; 344  : 				offset = block;	// offset = position to start for the Wrap write

	mov	eax, DWORD PTR _block$30420[ebp]
	mov	DWORD PTR _offset$30421[ebp], eax
$LN38@Write:

; 345  : 			}
; 346  : 		}

	jmp	$LN47@Write
$LN46@Write:

; 347  : 		//Update Loads
; 348  : 		w -= w2;

	mov	eax, DWORD PTR _w$[ebx]
	sub	eax, DWORD PTR _w2$30422[ebp]
	mov	DWORD PTR _w$[ebx], eax

; 349  : 		
; 350  : 		if (temp_NrPtrs > MINPTRS_FOR_SSE2 - 1)

	cmp	DWORD PTR _temp_NrPtrs$[ebp], 3
	jbe	$LN34@Write

; 351  : 			{
; 352  : 				//Update Loads using SSE2
; 353  : 				const unsigned int SSEops = this->Amount_SSE2_Operations;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _SSEops$30440[ebp], ecx

; 354  : 				
; 355  : 				for (unsigned int q=0;q<SSEops;q+=4)

	mov	DWORD PTR _q$30441[ebp], 0
	jmp	SHORT $LN33@Write
$LN32@Write:
	mov	eax, DWORD PTR _q$30441[ebp]
	add	eax, 4
	mov	DWORD PTR _q$30441[ebp], eax
$LN33@Write:
	mov	eax, DWORD PTR _q$30441[ebp]
	cmp	eax, DWORD PTR _SSEops$30440[ebp]
	jae	SHORT $LN31@Write

; 356  : 				{
; 357  : 					*(__m128i*)&temp_QLoad[q] = _mm_add_epi32(*(__m128i*)&temp_QLoad[q], _mm_set1_epi32 ((int)w));

	mov	eax, DWORD PTR _w$[ebx]
	movd	xmm0, eax
	pshufd	xmm0, xmm0, 0
	movdqa	XMMWORD PTR $T30448[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR $T30448[ebp]
	mov	ecx, DWORD PTR _q$30441[ebp]
	movdqa	xmm1, XMMWORD PTR _temp_QLoad$[ebp+ecx*4]
	paddd	xmm1, xmm0
	movdqa	XMMWORD PTR $T30449[ebp], xmm1
	mov	edx, DWORD PTR _q$30441[ebp]
	movdqa	xmm0, XMMWORD PTR $T30449[ebp]
	movdqa	XMMWORD PTR _temp_QLoad$[ebp+edx*4], xmm0

; 358  : 				}

	jmp	SHORT $LN32@Write
$LN31@Write:

; 359  : 
; 360  : 			}
; 361  : 			else

	jmp	SHORT $LN30@Write
$LN34@Write:

; 362  : 			{	// Simple Update Loads if amount of Read Channels is too low to gain speed
; 363  : 				for (unsigned int q=0;q<temp_NrPtrs;++q)

	mov	DWORD PTR _q$30451[ebp], 0
	jmp	SHORT $LN29@Write
$LN28@Write:
	mov	eax, DWORD PTR _q$30451[ebp]
	add	eax, 1
	mov	DWORD PTR _q$30451[ebp], eax
$LN29@Write:
	mov	eax, DWORD PTR _q$30451[ebp]
	cmp	eax, DWORD PTR _temp_NrPtrs$[ebp]
	jae	SHORT $LN30@Write

; 364  : 				{
; 365  : 					temp_QLoad[q] += w;	//Update loads

	mov	eax, DWORD PTR _q$30451[ebp]
	mov	ecx, DWORD PTR _temp_QLoad$[ebp+eax*4]
	add	ecx, DWORD PTR _w$[ebx]
	mov	edx, DWORD PTR _q$30451[ebp]
	mov	DWORD PTR _temp_QLoad$[ebp+edx*4], ecx

; 366  : 				}

	jmp	SHORT $LN28@Write
$LN30@Write:

; 367  : 			}
; 368  : 
; 369  : 	}
; 370  : 
; 371  : 	else	//FIFO

	jmp	$LN26@Write
$LN53@Write:

; 372  : 
; 373  : 	{
; 374  : 		unsigned int block;
; 375  : 		unsigned int offset=0;

	mov	DWORD PTR _offset$30457[ebp], 0

; 376  : 		unsigned int w2 = w;	// Keep a copy of written bytes to update Read pointer(s) & Load(s)

	mov	eax, DWORD PTR _w$[ebx]
	mov	DWORD PTR _w2$30458[ebp], eax
$LN25@Write:

; 377  : 		
; 378  : 			while (w2)

	cmp	DWORD PTR _w2$30458[ebp], 0
	je	$LN24@Write

; 379  : 			{
; 380  : 				block = temp_size - (temp_WrPtr+1);	// Get distance to Wrap point

	mov	eax, DWORD PTR _temp_WrPtr$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _temp_size$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _block$30456[ebp], ecx

; 381  : 
; 382  : 				if (w2 <= BLOCKSIZE_WRITE || block <= BLOCKSIZE_WRITE)	// Byte-by-Byte Read

	cmp	DWORD PTR _w2$30458[ebp], 8
	jbe	SHORT $LN22@Write
	cmp	DWORD PTR _block$30456[ebp], 8
	ja	$LN23@Write
$LN22@Write:

; 383  : 				{	// When not much data to write, or we're close at the wrap point, write byte-per-byte
; 384  : 					unsigned int Small = w2;

	mov	eax, DWORD PTR _w2$30458[ebp]
	mov	DWORD PTR _Small$30464[ebp], eax

; 385  : 
; 386  : 					if (Small > BLOCKSIZE_WRITE && (Small-block) > BLOCKSIZE_WRITE) Small = block+1;

	cmp	DWORD PTR _Small$30464[ebp], 8
	jbe	SHORT $LN21@Write
	mov	eax, DWORD PTR _Small$30464[ebp]
	sub	eax, DWORD PTR _block$30456[ebp]
	cmp	eax, 8
	jbe	SHORT $LN21@Write
	mov	eax, DWORD PTR _block$30456[ebp]
	add	eax, 1
	mov	DWORD PTR _Small$30464[ebp], eax
$LN21@Write:

; 387  : 
; 388  : 					for (unsigned int i=0;i<Small;++i)

	mov	DWORD PTR _i$30466[ebp], 0
	jmp	SHORT $LN20@Write
$LN19@Write:
	mov	eax, DWORD PTR _i$30466[ebp]
	add	eax, 1
	mov	DWORD PTR _i$30466[ebp], eax
$LN20@Write:
	mov	eax, DWORD PTR _i$30466[ebp]
	cmp	eax, DWORD PTR _Small$30464[ebp]
	jae	SHORT $LN18@Write

; 389  : 					{
; 390  : 						++temp_WrPtr;

	mov	eax, DWORD PTR _temp_WrPtr$[ebp]
	add	eax, 1
	mov	DWORD PTR _temp_WrPtr$[ebp], eax

; 391  : 						if (temp_WrPtr == temp_size) temp_WrPtr = 0;	// inc + compare&set is 40% faster than modulus trick

	mov	eax, DWORD PTR _temp_WrPtr$[ebp]
	cmp	eax, DWORD PTR _temp_size$[ebp]
	jne	SHORT $LN17@Write
	mov	DWORD PTR _temp_WrPtr$[ebp], 0
$LN17@Write:

; 392  : 						this->CQ[temp_WrPtr] = d[i+offset];

	mov	eax, DWORD PTR _i$30466[ebp]
	add	eax, DWORD PTR _offset$30457[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	ecx, DWORD PTR _temp_WrPtr$[ebp]
	mov	esi, DWORD PTR _d$[ebx]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al

; 393  : 						--w2;

	mov	eax, DWORD PTR _w2$30458[ebp]
	sub	eax, 1
	mov	DWORD PTR _w2$30458[ebp], eax

; 394  : 					}

	jmp	SHORT $LN19@Write
$LN18@Write:

; 395  : 				}
; 396  : 				else	// Block Write		Max block write = size of requested bytes (if possible)

	jmp	$LN16@Write
$LN23@Write:

; 397  : 				{
; 398  : 					if (block > w2) block = w2;	// If more sequential space is available than requested amount, write requested amount (otherwise we have a memory (& pointer) overflow

	mov	eax, DWORD PTR _block$30456[ebp]
	cmp	eax, DWORD PTR _w2$30458[ebp]
	jbe	SHORT $LN15@Write
	mov	eax, DWORD PTR _w2$30458[ebp]
	mov	DWORD PTR _block$30456[ebp], eax
$LN15@Write:

; 399  : 					if (block >= 4096)

	cmp	DWORD PTR _block$30456[ebp], 4096	; 00001000H
	jb	SHORT $LN14@Write

; 400  : 					{
; 401  : 						memcpy(&this->CQ[temp_WrPtr+1],d,block);	//Microsoft memcpy is faster >4k blocks

	mov	eax, DWORD PTR _block$30456[ebp]
	push	eax
	mov	ecx, DWORD PTR _d$[ebx]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	ecx, DWORD PTR _temp_WrPtr$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 402  : 					}
; 403  : 					else

	jmp	SHORT $LN13@Write
$LN14@Write:

; 404  : 					{
; 405  : 						A_memcpy(&this->CQ[temp_WrPtr+1],d,block);	//Agner Fog's lib is A LOT faster <4k blocks

	mov	eax, DWORD PTR _block$30456[ebp]
	push	eax
	mov	ecx, DWORD PTR _d$[ebx]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	ecx, DWORD PTR _temp_WrPtr$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	call	_A_memcpy
	add	esp, 12					; 0000000cH
$LN13@Write:

; 406  : 					}
; 407  : 					temp_WrPtr += block;

	mov	eax, DWORD PTR _temp_WrPtr$[ebp]
	add	eax, DWORD PTR _block$30456[ebp]
	mov	DWORD PTR _temp_WrPtr$[ebp], eax

; 408  : 					w2 -= block;	// Decrease nr of BytesToWrite

	mov	eax, DWORD PTR _w2$30458[ebp]
	sub	eax, DWORD PTR _block$30456[ebp]
	mov	DWORD PTR _w2$30458[ebp], eax

; 409  : 					offset = block;	// offset = position to start for the Wrap write

	mov	eax, DWORD PTR _block$30456[ebp]
	mov	DWORD PTR _offset$30457[ebp], eax
$LN16@Write:

; 410  : 				}
; 411  : 			}

	jmp	$LN25@Write
$LN24@Write:

; 412  : 			
; 413  : 			//Update Loads
; 414  : 			w -= w2;	//Update w to actual written amount

	mov	eax, DWORD PTR _w$[ebx]
	sub	eax, DWORD PTR _w2$30458[ebp]
	mov	DWORD PTR _w$[ebx], eax

; 415  : 						
; 416  : 			if (temp_NrPtrs >= MINPTRS_FOR_SSE2)

	cmp	DWORD PTR _temp_NrPtrs$[ebp], 4
	jb	$LN12@Write

; 417  : 			{
; 418  : 				//Update Loads using SSE2
; 419  : 				const unsigned int SSEops = this->Amount_SSE2_Operations;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _SSEops$30476[ebp], ecx

; 420  : 				
; 421  : 				for (unsigned int q=0;q<SSEops;q+=4)	//Update 4 Loads at a time

	mov	DWORD PTR _q$30477[ebp], 0
	jmp	SHORT $LN11@Write
$LN10@Write:
	mov	eax, DWORD PTR _q$30477[ebp]
	add	eax, 4
	mov	DWORD PTR _q$30477[ebp], eax
$LN11@Write:
	mov	eax, DWORD PTR _q$30477[ebp]
	cmp	eax, DWORD PTR _SSEops$30476[ebp]
	jae	SHORT $LN9@Write

; 422  : 				{
; 423  : 					*(__m128i*)&temp_QLoad[q] = _mm_add_epi32(*(__m128i*)&temp_QLoad[q], _mm_set1_epi32 ((int)w));

	mov	eax, DWORD PTR _w$[ebx]
	movd	xmm0, eax
	pshufd	xmm0, xmm0, 0
	movdqa	XMMWORD PTR $T30484[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR $T30484[ebp]
	mov	ecx, DWORD PTR _q$30477[ebp]
	movdqa	xmm1, XMMWORD PTR _temp_QLoad$[ebp+ecx*4]
	paddd	xmm1, xmm0
	movdqa	XMMWORD PTR $T30485[ebp], xmm1
	mov	edx, DWORD PTR _q$30477[ebp]
	movdqa	xmm0, XMMWORD PTR $T30485[ebp]
	movdqa	XMMWORD PTR _temp_QLoad$[ebp+edx*4], xmm0

; 424  : 				}

	jmp	SHORT $LN10@Write
$LN9@Write:

; 425  : 
; 426  : 			}
; 427  : 			else

	jmp	SHORT $LN8@Write
$LN12@Write:

; 428  : 			{	// Simple Update Loads if amount of Read Channels is too low to gain speed
; 429  : 				for (unsigned int q=0;q<temp_NrPtrs;++q)

	mov	DWORD PTR _q$30487[ebp], 0
	jmp	SHORT $LN7@Write
$LN6@Write:
	mov	eax, DWORD PTR _q$30487[ebp]
	add	eax, 1
	mov	DWORD PTR _q$30487[ebp], eax
$LN7@Write:
	mov	eax, DWORD PTR _q$30487[ebp]
	cmp	eax, DWORD PTR _temp_NrPtrs$[ebp]
	jae	SHORT $LN8@Write

; 430  : 				{
; 431  : 					temp_QLoad[q] += w;	//Update loads

	mov	eax, DWORD PTR _q$30487[ebp]
	mov	ecx, DWORD PTR _temp_QLoad$[ebp+eax*4]
	add	ecx, DWORD PTR _w$[ebx]
	mov	edx, DWORD PTR _q$30487[ebp]
	mov	DWORD PTR _temp_QLoad$[ebp+edx*4], ecx

; 432  : 				}

	jmp	SHORT $LN6@Write
$LN8@Write:

; 433  : 			}
; 434  : 
; 435  : 			// Update Pointers & Check Overflow
; 436  : 			unsigned int CacheCopy_OverFlow = 0;

	mov	DWORD PTR _CacheCopy_OverFlow$30491[ebp], 0

; 437  : 
; 438  : 			for (unsigned int q=0;q<temp_NrPtrs;++q)

	mov	DWORD PTR _q$30492[ebp], 0
	jmp	SHORT $LN4@Write
$LN3@Write:
	mov	eax, DWORD PTR _q$30492[ebp]
	add	eax, 1
	mov	DWORD PTR _q$30492[ebp], eax
$LN4@Write:
	mov	eax, DWORD PTR _q$30492[ebp]
	cmp	eax, DWORD PTR _temp_NrPtrs$[ebp]
	jae	SHORT $LN2@Write

; 439  : 			{	
; 440  : 				if (temp_QLoad[q] > temp_size)	// New Load is larger/equal then/to queue size

	mov	eax, DWORD PTR _q$30492[ebp]
	mov	ecx, DWORD PTR _temp_QLoad$[ebp+eax*4]
	cmp	ecx, DWORD PTR _temp_size$[ebp]
	jbe	SHORT $LN1@Write

; 441  : 				{
; 442  : 					temp_QLoad[q] = temp_size; // Max. possible amount is queue size

	mov	eax, DWORD PTR _q$30492[ebp]
	mov	ecx, DWORD PTR _temp_size$[ebp]
	mov	DWORD PTR _temp_QLoad$[ebp+eax*4], ecx

; 443  : 					temp_RdPtr[q] = temp_WrPtr; // Pointers are equal when buffer is full

	mov	eax, DWORD PTR _q$30492[ebp]
	mov	ecx, DWORD PTR _temp_WrPtr$[ebp]
	mov	DWORD PTR _temp_RdPtr$[ebp+eax*4], ecx

; 444  : 					CacheCopy_OverFlow = 1; //If new amount of data is larger then the queue, we lost data ..

	mov	DWORD PTR _CacheCopy_OverFlow$30491[ebp], 1
$LN1@Write:

; 445  : 				}
; 446  : 			}

	jmp	SHORT $LN3@Write
$LN2@Write:

; 447  : 
; 448  : 			this->OverFlow = CacheCopy_OverFlow;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _CacheCopy_OverFlow$30491[ebp]
	mov	DWORD PTR [eax+40], ecx
$LN26@Write:

; 449  : 	}
; 450  : 
; 451  : 	// Write back changed value's to RAM
; 452  : 	this->WrPtr = temp_WrPtr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _temp_WrPtr$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 453  : 
; 454  : 	A_memcpy(&this->QLoad[0], &temp_QLoad[0], temp_NrPtrs*sizeof (unsigned int));

	mov	eax, DWORD PTR _temp_NrPtrs$[ebp]
	shl	eax, 2
	push	eax
	lea	ecx, DWORD PTR _temp_QLoad$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 592				; 00000250H
	push	edx
	call	_A_memcpy
	add	esp, 12					; 0000000cH

; 455  : 	A_memcpy(&this->RdPtr[0], &temp_RdPtr[0], temp_NrPtrs*sizeof (unsigned int));

	mov	eax, DWORD PTR _temp_NrPtrs$[ebp]
	shl	eax, 2
	push	eax
	lea	ecx, DWORD PTR _temp_RdPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 80					; 00000050H
	push	edx
	call	_A_memcpy
	add	esp, 12					; 0000000cH

; 456  : 
; 457  : 
; 458  : 	// Exit
; 459  : 	LeaveCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 460  : 	return 0;

	xor	eax, eax
$LN55@Write:

; 461  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	8
?Write@Buffers@@QAEHIPAE@Z ENDP				; Buffers::Write
_TEXT	ENDS
PUBLIC	?GetBuffertype@Buffers@@QAEIXZ			; Buffers::GetBuffertype
; Function compile flags: /Odtp /ZI
;	COMDAT ?GetBuffertype@Buffers@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuffertype@Buffers@@QAEIXZ PROC			; Buffers::GetBuffertype, COMDAT
; _this$ = ecx

; 464  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 465  : 	return this->BufferType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 466  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuffertype@Buffers@@QAEIXZ ENDP			; Buffers::GetBuffertype
_TEXT	ENDS
PUBLIC	?CQsize@Buffers@@QAEIXZ				; Buffers::CQsize
; Function compile flags: /Odtp /ZI
;	COMDAT ?CQsize@Buffers@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CQsize@Buffers@@QAEIXZ PROC				; Buffers::CQsize, COMDAT
; _this$ = ecx

; 469  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 470  : 	return this->size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 471  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CQsize@Buffers@@QAEIXZ ENDP				; Buffers::CQsize
_TEXT	ENDS
PUBLIC	?StatusGetOverFlow@Buffers@@QAEIXZ		; Buffers::StatusGetOverFlow
; Function compile flags: /Odtp /ZI
;	COMDAT ?StatusGetOverFlow@Buffers@@QAEIXZ
_TEXT	SEGMENT
_a$ = -8						; size = 4
_this$ = -4						; size = 4
?StatusGetOverFlow@Buffers@@QAEIXZ PROC			; Buffers::StatusGetOverFlow, COMDAT
; _this$ = ecx

; 474  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 475  : 	unsigned int a = 0;

	mov	DWORD PTR _a$[ebp], 0

; 476  : 	
; 477  : 	EnterCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__EnterCriticalSection@4

; 478  : 		a = this->OverFlow;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _a$[ebp], ecx

; 479  : 	LeaveCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 480  : 
; 481  : 	return a;

	mov	eax, DWORD PTR _a$[ebp]

; 482  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StatusGetOverFlow@Buffers@@QAEIXZ ENDP			; Buffers::StatusGetOverFlow
_TEXT	ENDS
PUBLIC	?StatusClearOverFlow@Buffers@@QAEXXZ		; Buffers::StatusClearOverFlow
; Function compile flags: /Odtp /ZI
;	COMDAT ?StatusClearOverFlow@Buffers@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StatusClearOverFlow@Buffers@@QAEXXZ PROC		; Buffers::StatusClearOverFlow, COMDAT
; _this$ = ecx

; 485  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 486  : 	EnterCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__EnterCriticalSection@4

; 487  : 		this->OverFlow = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 488  : 	LeaveCriticalSection(&Crit1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 489  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StatusClearOverFlow@Buffers@@QAEXXZ ENDP		; Buffers::StatusClearOverFlow
_TEXT	ENDS
PUBLIC	_BufferCreate@16
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_BufferCreate@16$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_BufferCreate@16$0
__tryblocktable$_BufferCreate@16 DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$_BufferCreate@16$3
__unwindtable$_BufferCreate@16 DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_BufferCreate@16$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$_BufferCreate@16 DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$_BufferCreate@16
	DD	01H
	DD	FLAT:__tryblocktable$_BufferCreate@16
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT _BufferCreate@16
_TEXT	SEGMENT
tv79 = -124						; size = 4
tv130 = -120						; size = 4
tv91 = -120						; size = 4
tv131 = -116						; size = 4
tv128 = -116						; size = 4
$T30720 = -112						; size = 4
$T30711 = -108						; size = 4
$T30712 = -104						; size = 4
$T30715 = -100						; size = 4
$T30716 = -96						; size = 4
$T30717 = -92						; size = 4
_NewBuffer$ = -24					; size = 4
_i$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_size$ = 8						; size = 4
_buffertype$ = 12					; size = 4
_NrReadChannels$ = 16					; size = 4
_Status$ = 20						; size = 4
_BufferCreate@16 PROC					; COMDAT

; 496  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$_BufferCreate@16
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 497  : 	unsigned int i=0;

	mov	DWORD PTR _i$[ebp], 0

; 498  : 	*Status = 0;

	mov	eax, DWORD PTR _Status$[ebp]
	mov	DWORD PTR [eax], 0

; 499  : 	
; 500  : 	if (NrReadChannels > MAXPTRS) NrReadChannels = MAXPTRS;	// Check (and set) maximum allowed nr of Read Pointers

	cmp	DWORD PTR _NrReadChannels$[ebp], 128	; 00000080H
	jbe	SHORT $LN8@BufferCrea
	mov	DWORD PTR _NrReadChannels$[ebp], 128	; 00000080H
$LN8@BufferCrea:

; 501  : 	if (!NrReadChannels) {*Status = -1 ;return 0;}	// ReadChannels must be at least 1

	cmp	DWORD PTR _NrReadChannels$[ebp], 0
	jne	SHORT $LN7@BufferCrea
	mov	eax, DWORD PTR _Status$[ebp]
	mov	DWORD PTR [eax], -1
	xor	eax, eax
	jmp	$LN10@BufferCrea
$LN7@BufferCrea:

; 502  : 
; 503  : 	if (size > 1048576*MAXSIZE) size = 1048576*MAXSIZE;	// Buffer Maximum Capacity

	cmp	DWORD PTR _size$[ebp], 536870912	; 20000000H
	jbe	SHORT $LN6@BufferCrea
	mov	DWORD PTR _size$[ebp], 536870912	; 20000000H
$LN6@BufferCrea:

; 504  : 	if (size < MINSIZE) size = MINSIZE;	// Buffer Minimum Capacity

	cmp	DWORD PTR _size$[ebp], 16		; 00000010H
	jae	SHORT $LN5@BufferCrea
	mov	DWORD PTR _size$[ebp], 16		; 00000010H
$LN5@BufferCrea:

; 505  : 
; 506  : 	if (buffertype > 1) {*Status = -2 ;return 0;}	// Unknown Buffertype

	cmp	DWORD PTR _buffertype$[ebp], 1
	jbe	SHORT $LN4@BufferCrea
	mov	eax, DWORD PTR _Status$[ebp]
	mov	DWORD PTR [eax], -2			; fffffffeH
	xor	eax, eax
	jmp	$LN10@BufferCrea
$LN4@BufferCrea:

; 507  : 	
; 508  : 	Buffers * NewBuffer;
; 509  : 
; 510  : 	try
; 511  : 	{

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 512  : 		NewBuffer = new Buffers(NrReadChannels, size, buffertype);

	push	1104					; 00000450H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv128[ebp], eax
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR $T30712[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T30712[ebp], 0
	je	SHORT $LN11@BufferCrea
	mov	ecx, DWORD PTR _buffertype$[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _NrReadChannels$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T30712[ebp]
	call	??0Buffers@@QAE@III@Z			; Buffers::Buffers
	mov	DWORD PTR tv130[ebp], eax
	mov	ecx, DWORD PTR tv130[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN12@BufferCrea
$LN11@BufferCrea:
	mov	DWORD PTR tv79[ebp], 0
$LN12@BufferCrea:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T30711[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR $T30711[ebp]
	mov	DWORD PTR _NewBuffer$[ebp], eax

; 513  : 		if (!NewBuffer) throw -1;

	cmp	DWORD PTR _NewBuffer$[ebp], 0
	jne	SHORT $LN2@BufferCrea
	mov	DWORD PTR $T30715[ebp], -1
	push	OFFSET __TI1H
	lea	eax, DWORD PTR $T30715[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@BufferCrea:

; 514  : 
; 515  : 		if (NewBuffer->QueueError)

	mov	eax, DWORD PTR _NewBuffer$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN1@BufferCrea

; 516  : 			{
; 517  : 				delete NewBuffer;

	mov	eax, DWORD PTR _NewBuffer$[ebp]
	mov	DWORD PTR $T30717[ebp], eax
	mov	ecx, DWORD PTR $T30717[ebp]
	mov	DWORD PTR $T30716[ebp], ecx
	cmp	DWORD PTR $T30716[ebp], 0
	je	SHORT $LN13@BufferCrea
	push	1
	mov	edx, DWORD PTR $T30716[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T30716[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv131[ebp], eax
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN14@BufferCrea
$LN13@BufferCrea:
	mov	DWORD PTR tv91[ebp], 0
$LN14@BufferCrea:

; 518  : 				throw -1;

	mov	DWORD PTR $T30720[ebp], -1
	push	OFFSET __TI1H
	lea	eax, DWORD PTR $T30720[ebp]
	push	eax
	call	__CxxThrowException@8
$LN1@BufferCrea:

; 519  : 			}
; 520  : 	}

	jmp	SHORT $LN15@BufferCrea
__catch$_BufferCreate@16$0:

; 521  : 	catch (...)
; 522  : 	{
; 523  : 		NewBuffer = nullptr;

	mov	DWORD PTR _NewBuffer$[ebp], 0

; 524  : 		*Status = -3;	// Out of memory

	mov	eax, DWORD PTR _Status$[ebp]
	mov	DWORD PTR [eax], -3			; fffffffdH

; 525  : 	}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$_BufferCreate@16$1
	ret	0
$LN15@BufferCrea:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$_BufferCreate@16$1:

; 526  : 	
; 527  : 	i = (unsigned int) NewBuffer;

	mov	eax, DWORD PTR _NewBuffer$[ebp]
	mov	DWORD PTR _i$[ebp], eax

; 528  : 	return i;

	mov	eax, DWORD PTR _i$[ebp]
$LN10@BufferCrea:

; 529  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_BufferCreate@16$2:
	mov	eax, DWORD PTR $T30712[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$_BufferCreate@16:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$_BufferCreate@16
	jmp	___CxxFrameHandler3
text$x	ENDS
_BufferCreate@16 ENDP
PUBLIC	_BufferRelease@4
; Function compile flags: /Odtp /ZI
;	COMDAT _BufferRelease@4
_TEXT	SEGMENT
tv70 = -80						; size = 4
$T30737 = -76						; size = 4
$T30738 = -72						; size = 4
_incoming$ = -4						; size = 4
_buffer_nr$ = 8						; size = 4
_BufferRelease@4 PROC					; COMDAT

; 532  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 533  : 	Buffers * incoming = (Buffers*) buffer_nr;

	mov	eax, DWORD PTR _buffer_nr$[ebp]
	mov	DWORD PTR _incoming$[ebp], eax

; 534  : 	delete incoming;

	mov	eax, DWORD PTR _incoming$[ebp]
	mov	DWORD PTR $T30738[ebp], eax
	mov	ecx, DWORD PTR $T30738[ebp]
	mov	DWORD PTR $T30737[ebp], ecx
	cmp	DWORD PTR $T30737[ebp], 0
	je	SHORT $LN3@BufferRele
	push	1
	mov	edx, DWORD PTR $T30737[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T30737[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN4@BufferRele
$LN3@BufferRele:
	mov	DWORD PTR tv70[ebp], 0
$LN4@BufferRele:

; 535  : 	incoming = nullptr;

	mov	DWORD PTR _incoming$[ebp], 0

; 536  : 	return;
; 537  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_BufferRelease@4 ENDP
_TEXT	ENDS
PUBLIC	_BufferRead@16
; Function compile flags: /Odtp /ZI
;	COMDAT _BufferRead@16
_TEXT	SEGMENT
_incoming$ = -4						; size = 4
_buffer_nr$ = 8						; size = 4
_ReadChannel$ = 12					; size = 4
_NrOfBytes$ = 16					; size = 4
_Data$ = 20						; size = 4
_BufferRead@16 PROC					; COMDAT

; 540  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 541  : 	Buffers * incoming = (Buffers*) buffer_nr;

	mov	eax, DWORD PTR _buffer_nr$[ebp]
	mov	DWORD PTR _incoming$[ebp], eax

; 542  : 	return incoming->Read(ReadChannel, NrOfBytes,Data);

	mov	eax, DWORD PTR _Data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _NrOfBytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ReadChannel$[ebp]
	push	edx
	mov	ecx, DWORD PTR _incoming$[ebp]
	call	?Read@Buffers@@QAEHIIPAE@Z		; Buffers::Read

; 543  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_BufferRead@16 ENDP
_TEXT	ENDS
PUBLIC	_BufferWrite@12
; Function compile flags: /Odtp /ZI
;	COMDAT _BufferWrite@12
_TEXT	SEGMENT
_incoming$ = -4						; size = 4
_buffer_nr$ = 8						; size = 4
_NrOfBytes$ = 12					; size = 4
_Data$ = 16						; size = 4
_BufferWrite@12 PROC					; COMDAT

; 546  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 547  : 	Buffers * incoming = (Buffers*) buffer_nr;

	mov	eax, DWORD PTR _buffer_nr$[ebp]
	mov	DWORD PTR _incoming$[ebp], eax

; 548  : 	return incoming->Write(NrOfBytes,Data);

	mov	eax, DWORD PTR _Data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _NrOfBytes$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _incoming$[ebp]
	call	?Write@Buffers@@QAEHIPAE@Z		; Buffers::Write

; 549  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_BufferWrite@12 ENDP
_TEXT	ENDS
PUBLIC	_BufferFlush@8
; Function compile flags: /Odtp /ZI
;	COMDAT _BufferFlush@8
_TEXT	SEGMENT
_incoming$ = -4						; size = 4
_buffer_nr$ = 8						; size = 4
_ReadChannel$ = 12					; size = 4
_BufferFlush@8 PROC					; COMDAT

; 552  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 553  : 	Buffers * incoming = (Buffers*) buffer_nr;

	mov	eax, DWORD PTR _buffer_nr$[ebp]
	mov	DWORD PTR _incoming$[ebp], eax

; 554  : 	incoming->Flush(ReadChannel);

	mov	eax, DWORD PTR _ReadChannel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _incoming$[ebp]
	call	?Flush@Buffers@@QAEXH@Z			; Buffers::Flush

; 555  : 	return;
; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_BufferFlush@8 ENDP
_TEXT	ENDS
PUBLIC	_BufferSpaceAvailable@8
; Function compile flags: /Odtp /ZI
;	COMDAT _BufferSpaceAvailable@8
_TEXT	SEGMENT
_incoming$ = -4						; size = 4
_buffer_nr$ = 8						; size = 4
_ReadChannel$ = 12					; size = 4
_BufferSpaceAvailable@8 PROC				; COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 560  : 	Buffers * incoming = (Buffers*) buffer_nr;

	mov	eax, DWORD PTR _buffer_nr$[ebp]
	mov	DWORD PTR _incoming$[ebp], eax

; 561  : 	return incoming->QFree(ReadChannel);

	mov	eax, DWORD PTR _ReadChannel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _incoming$[ebp]
	call	?QFree@Buffers@@QAEII@Z			; Buffers::QFree

; 562  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_BufferSpaceAvailable@8 ENDP
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	__real@0000000000000000
PUBLIC	_BufferSpaceAvailable_Percentage@8
EXTRN	__fltused:DWORD
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _BufferSpaceAvailable_Percentage@8
_TEXT	SEGMENT
tv90 = -104						; size = 8
tv95 = -96						; size = 8
tv86 = -88						; size = 8
tv81 = -88						; size = 8
_incoming$ = -16					; size = 4
_k$ = -12						; size = 8
_a$ = -4						; size = 4
_buffer_nr$ = 8						; size = 4
_ReadChannel$ = 12					; size = 4
_BufferSpaceAvailable_Percentage@8 PROC			; COMDAT

; 565  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 566  : 	unsigned int a =0;

	mov	DWORD PTR _a$[ebp], 0

; 567  : 	double k =0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _k$[ebp], xmm0

; 568  : 	Buffers * incoming = (Buffers*) buffer_nr;

	mov	eax, DWORD PTR _buffer_nr$[ebp]
	mov	DWORD PTR _incoming$[ebp], eax

; 569  : 	a = incoming->QFree(ReadChannel);

	mov	eax, DWORD PTR _ReadChannel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _incoming$[ebp]
	call	?QFree@Buffers@@QAEII@Z			; Buffers::QFree
	mov	DWORD PTR _a$[ebp], eax

; 570  : 	
; 571  : 	if (a < 0) return a;

	cmp	DWORD PTR _a$[ebp], 0
	jae	SHORT $LN1@BufferSpac
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	mov	DWORD PTR tv81[ebp+4], 0
	fild	QWORD PTR tv81[ebp]
	jmp	SHORT $LN2@BufferSpac
$LN1@BufferSpac:

; 572  : 	
; 573  : 	k = ((double)a / (double)incoming->CQsize())*100;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR tv86[ebp], eax
	mov	DWORD PTR tv86[ebp+4], 0
	fild	QWORD PTR tv86[ebp]
	mov	ecx, DWORD PTR _incoming$[ebp]
	fstp	QWORD PTR tv95[ebp]
	call	?CQsize@Buffers@@QAEIXZ			; Buffers::CQsize
	mov	DWORD PTR tv90[ebp], eax
	mov	DWORD PTR tv90[ebp+4], 0
	fild	QWORD PTR tv90[ebp]
	fdivr	QWORD PTR tv95[ebp]
	fmul	QWORD PTR __real@4059000000000000
	fstp	QWORD PTR _k$[ebp]

; 574  : 
; 575  : 	return  k;

	fld	QWORD PTR _k$[ebp]
$LN2@BufferSpac:

; 576  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_BufferSpaceAvailable_Percentage@8 ENDP
_TEXT	ENDS
PUBLIC	_BufferSpaceUsed@8
; Function compile flags: /Odtp /ZI
;	COMDAT _BufferSpaceUsed@8
_TEXT	SEGMENT
_incoming$ = -4						; size = 4
_buffer_nr$ = 8						; size = 4
_ReadChannel$ = 12					; size = 4
_BufferSpaceUsed@8 PROC					; COMDAT

; 579  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 580  : 	Buffers * incoming = (Buffers*) buffer_nr;

	mov	eax, DWORD PTR _buffer_nr$[ebp]
	mov	DWORD PTR _incoming$[ebp], eax

; 581  : 	return incoming->QLoaded(ReadChannel);

	mov	eax, DWORD PTR _ReadChannel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _incoming$[ebp]
	call	?QLoaded@Buffers@@QAEII@Z		; Buffers::QLoaded

; 582  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_BufferSpaceUsed@8 ENDP
_TEXT	ENDS
PUBLIC	_BufferSpaceUsed_Percentage@8
; Function compile flags: /Odtp /ZI
;	COMDAT _BufferSpaceUsed_Percentage@8
_TEXT	SEGMENT
tv82 = -100						; size = 8
tv87 = -92						; size = 8
tv78 = -84						; size = 8
_incoming$ = -12					; size = 4
_k$ = -8						; size = 8
_buffer_nr$ = 8						; size = 4
_ReadChannel$ = 12					; size = 4
_BufferSpaceUsed_Percentage@8 PROC			; COMDAT

; 585  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 586  : 	double k =0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _k$[ebp], xmm0

; 587  : 	Buffers * incoming = (Buffers*) buffer_nr;

	mov	eax, DWORD PTR _buffer_nr$[ebp]
	mov	DWORD PTR _incoming$[ebp], eax

; 588  : 	k = ((double)incoming->QLoaded(ReadChannel) / (double)incoming->CQsize())*100;

	mov	eax, DWORD PTR _ReadChannel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _incoming$[ebp]
	call	?QLoaded@Buffers@@QAEII@Z		; Buffers::QLoaded
	mov	DWORD PTR tv78[ebp], eax
	mov	DWORD PTR tv78[ebp+4], 0
	fild	QWORD PTR tv78[ebp]
	mov	ecx, DWORD PTR _incoming$[ebp]
	fstp	QWORD PTR tv87[ebp]
	call	?CQsize@Buffers@@QAEIXZ			; Buffers::CQsize
	mov	DWORD PTR tv82[ebp], eax
	mov	DWORD PTR tv82[ebp+4], 0
	fild	QWORD PTR tv82[ebp]
	fdivr	QWORD PTR tv87[ebp]
	fmul	QWORD PTR __real@4059000000000000
	fstp	QWORD PTR _k$[ebp]

; 589  : 	return  k;

	fld	QWORD PTR _k$[ebp]

; 590  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_BufferSpaceUsed_Percentage@8 ENDP
_TEXT	ENDS
PUBLIC	_BufferGetOverflow_Wait@4
; Function compile flags: /Odtp /ZI
;	COMDAT _BufferGetOverflow_Wait@4
_TEXT	SEGMENT
_incoming$ = -4						; size = 4
_buffer_nr$ = 8						; size = 4
_BufferGetOverflow_Wait@4 PROC				; COMDAT

; 593  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 594  : 	Buffers * incoming = (Buffers*) buffer_nr;

	mov	eax, DWORD PTR _buffer_nr$[ebp]
	mov	DWORD PTR _incoming$[ebp], eax

; 595  : 	return incoming->StatusGetOverFlow();

	mov	ecx, DWORD PTR _incoming$[ebp]
	call	?StatusGetOverFlow@Buffers@@QAEIXZ	; Buffers::StatusGetOverFlow

; 596  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_BufferGetOverflow_Wait@4 ENDP
_TEXT	ENDS
PUBLIC	_BufferClearOverflow_Wait@4
; Function compile flags: /Odtp /ZI
;	COMDAT _BufferClearOverflow_Wait@4
_TEXT	SEGMENT
_incoming$ = -4						; size = 4
_buffer_nr$ = 8						; size = 4
_BufferClearOverflow_Wait@4 PROC			; COMDAT

; 599  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 600  : 	Buffers * incoming = (Buffers*) buffer_nr;

	mov	eax, DWORD PTR _buffer_nr$[ebp]
	mov	DWORD PTR _incoming$[ebp], eax

; 601  : 	incoming->StatusClearOverFlow();

	mov	ecx, DWORD PTR _incoming$[ebp]
	call	?StatusClearOverFlow@Buffers@@QAEXXZ	; Buffers::StatusClearOverFlow

; 602  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_BufferClearOverflow_Wait@4 ENDP
_TEXT	ENDS
END
