; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\xback\Documents\Visual Studio 2010\Projects\Buffers\Buffers\UltraQueue.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4Buffers@@6B@				; Buffers::`RTTI Complete Object Locator'
PUBLIC	??_R3Buffers@@8					; Buffers::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Buffers@@8					; Buffers::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Buffers@@8			; Buffers::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVBuffers@@@8				; Buffers `RTTI Type Descriptor'
PUBLIC	??_GBuffers@@UAEPAXI@Z				; Buffers::`scalar deleting destructor'
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
PUBLIC	__CT??_R0H@84
PUBLIC	__CTA1H
PUBLIC	__TI1H
PUBLIC	??_7Buffers@@6B@				; Buffers::`vftable'
EXTRN	__imp__InitializeCriticalSectionAndSpinCount@8:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	??_EBuffers@@UAEPAXI@Z:PROC			; Buffers::`vector deleting destructor'
EXTRN	_A_memcpy:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp_??2@YAPAXI@Z:PROC
EXTRN	__imp_??3@YAXPAX@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_7Buffers@@6B@
CONST	SEGMENT
??_7Buffers@@6B@ DD FLAT:??_R4Buffers@@6B@		; Buffers::`vftable'
	DD	FLAT:??_EBuffers@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4Buffers@@6B@
rdata$r	SEGMENT
??_R4Buffers@@6B@ DD 00H				; Buffers::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBuffers@@@8
	DD	FLAT:??_R3Buffers@@8
rdata$r	ENDS
;	COMDAT ??_R3Buffers@@8
rdata$r	SEGMENT
??_R3Buffers@@8 DD 00H					; Buffers::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Buffers@@8
rdata$r	ENDS
;	COMDAT ??_R2Buffers@@8
rdata$r	SEGMENT
??_R2Buffers@@8 DD FLAT:??_R1A@?0A@EA@Buffers@@8	; Buffers::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Buffers@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Buffers@@8 DD FLAT:??_R0?AVBuffers@@@8	; Buffers::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Buffers@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBuffers@@@8
_DATA	SEGMENT
??_R0?AVBuffers@@@8 DD FLAT:??_7type_info@@6B@		; Buffers `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBuffers@@', 00H
_DATA	ENDS
;	COMDAT __TI1H
xdata$x	SEGMENT
__TI1H	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1H
xdata$x	ENDS
;	COMDAT __CTA1H
xdata$x	SEGMENT
__CTA1H	DD	01H
	DD	FLAT:__CT??_R0H@84
xdata$x	ENDS
;	COMDAT __CT??_R0H@84
xdata$x	SEGMENT
__CT??_R0H@84 DD 01H
	DD	FLAT:??_R0H@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0H@8
_DATA	SEGMENT
??_R0H@8 DD	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DD	00H
	DB	'.H', 00H
_DATA	ENDS
PUBLIC	_BufferRelease@4
; Function compile flags: /Ogtpy
; File c:\users\xback\documents\visual studio 2010\projects\buffers\buffers\ultraqueue.cpp
;	COMDAT _BufferRelease@4
_TEXT	SEGMENT
_buffer_nr$ = 8						; size = 4
_BufferRelease@4 PROC					; COMDAT

; 533  : 	Buffers * incoming = (Buffers*) buffer_nr;
; 534  : 	delete incoming;

	mov	ecx, DWORD PTR _buffer_nr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@BufferRele
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _buffer_nr$[esp-4], 1
	jmp	edx
$LN3@BufferRele:

; 535  : 	incoming = nullptr;
; 536  : 	return;
; 537  : }

	ret	4
_BufferRelease@4 ENDP
_TEXT	ENDS
PUBLIC	?StatusClearOverFlow@Buffers@@QAEXXZ		; Buffers::StatusClearOverFlow
; Function compile flags: /Ogtpy
;	COMDAT ?StatusClearOverFlow@Buffers@@QAEXXZ
_TEXT	SEGMENT
?StatusClearOverFlow@Buffers@@QAEXXZ PROC		; Buffers::StatusClearOverFlow, COMDAT
; _this$ = edi

; 485  : {

	push	esi

; 486  : 	EnterCriticalSection(&Crit1);

	lea	esi, DWORD PTR [edi+44]
	push	esi
	call	DWORD PTR __imp__EnterCriticalSection@4

; 487  : 		this->OverFlow = 0;
; 488  : 	LeaveCriticalSection(&Crit1);

	push	esi
	mov	DWORD PTR [edi+40], 0
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	esi

; 489  : }

	ret	0
?StatusClearOverFlow@Buffers@@QAEXXZ ENDP		; Buffers::StatusClearOverFlow
_TEXT	ENDS
PUBLIC	?StatusGetOverFlow@Buffers@@QAEIXZ		; Buffers::StatusGetOverFlow
; Function compile flags: /Ogtpy
;	COMDAT ?StatusGetOverFlow@Buffers@@QAEIXZ
_TEXT	SEGMENT
?StatusGetOverFlow@Buffers@@QAEIXZ PROC			; Buffers::StatusGetOverFlow, COMDAT
; _this$ = eax

; 474  : {

	push	esi
	push	edi
	mov	edi, eax

; 475  : 	unsigned int a = 0;
; 476  : 	
; 477  : 	EnterCriticalSection(&Crit1);

	lea	esi, DWORD PTR [edi+44]
	push	esi
	call	DWORD PTR __imp__EnterCriticalSection@4

; 478  : 		a = this->OverFlow;

	mov	edi, DWORD PTR [edi+40]

; 479  : 	LeaveCriticalSection(&Crit1);

	push	esi
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 480  : 
; 481  : 	return a;

	mov	eax, edi
	pop	edi
	pop	esi

; 482  : }

	ret	0
?StatusGetOverFlow@Buffers@@QAEIXZ ENDP			; Buffers::StatusGetOverFlow
_TEXT	ENDS
PUBLIC	?CQsize@Buffers@@QAEIXZ				; Buffers::CQsize
; Function compile flags: /Ogtpy
;	COMDAT ?CQsize@Buffers@@QAEIXZ
_TEXT	SEGMENT
?CQsize@Buffers@@QAEIXZ PROC				; Buffers::CQsize, COMDAT
; _this$ = eax

; 470  : 	return this->size;

	mov	eax, DWORD PTR [eax+20]

; 471  : }

	ret	0
?CQsize@Buffers@@QAEIXZ ENDP				; Buffers::CQsize
_TEXT	ENDS
PUBLIC	_d$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?Write@Buffers@@QAEHIPAE@Z			; Buffers::Write
EXTRN	___security_cookie:DWORD
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Write@Buffers@@QAEHIPAE@Z
_TEXT	SEGMENT
_this$GSCopy$ = -1084					; size = 4
_d$GSCopy$ = -1080					; size = 4
_temp_size$ = -1076					; size = 4
_offset$30448 = -1072					; size = 4
_offset$30412 = -1072					; size = 4
_temp_NrPtrs$ = -1068					; size = 4
tv417 = -1064						; size = 4
tv757 = -1060						; size = 4
tv510 = -1060						; size = 4
tv756 = -1056						; size = 4
tv467 = -1056						; size = 4
tv427 = -1052						; size = 4
tv429 = -1048						; size = 4
tv428 = -1044						; size = 4
_temp_QLoad$ = -1040					; size = 512
_temp_RdPtr$ = -528					; size = 512
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_w$ = 12						; size = 4
_d$ = 16						; size = 4
?Write@Buffers@@QAEHIPAE@Z PROC				; Buffers::Write, COMDAT

; 274  : {

	push	ebp
	mov	ebp, esp
	and	esp, -16				; fffffff0H
	sub	esp, 1092				; 00000444H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+1092], eax

; 275  : 	if (!w) return -1;	// A minimum of 1 byte should be requested

	cmp	DWORD PTR _w$[ebp], 0
	mov	eax, DWORD PTR _d$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _this$[ebp]
	push	esi
	push	edi

; 377  : 		
; 378  : 			while (w2)

	mov	DWORD PTR _this$GSCopy$[esp+1104], ebx
	mov	DWORD PTR _d$GSCopy$[esp+1104], eax
	jne	SHORT $LN54@Write

; 275  : 	if (!w) return -1;	// A minimum of 1 byte should be requested

	or	eax, -1

; 460  : 	return 0;
; 461  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+1092]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN54@Write:

; 276  : 	EnterCriticalSection(&Crit1);

	lea	eax, DWORD PTR [ebx+44]
	push	eax
	mov	DWORD PTR tv417[esp+1108], eax
	call	DWORD PTR __imp__EnterCriticalSection@4

; 277  : 	
; 278  : 	//Copy class vars to local vars for caching purposes (~ +95% speed increase)
; 279  : 	
; 280  : 	const unsigned int temp_size = this->size;
; 281  : 	const unsigned int temp_NrPtrs = this->NrPtrs;

	mov	eax, DWORD PTR [ebx+32]
	mov	edi, DWORD PTR [ebx+20]

; 282  : 	unsigned int temp_WrPtr = this->WrPtr;

	mov	esi, DWORD PTR [ebx+24]
	mov	DWORD PTR _temp_NrPtrs$[esp+1104], eax

; 283  : 	__declspec (align(16)) unsigned int temp_QLoad[MAXPTRS];
; 284  : 	__declspec (align(16)) unsigned int temp_RdPtr[MAXPTRS];
; 285  : 	
; 286  : 	A_memcpy(&temp_QLoad[0],&this->QLoad[0],temp_NrPtrs*sizeof (unsigned int));

	add	eax, eax
	add	eax, eax
	lea	ecx, DWORD PTR [ebx+592]
	push	eax
	push	ecx
	mov	DWORD PTR tv428[esp+1112], ecx
	lea	ecx, DWORD PTR _temp_QLoad$[esp+1112]
	push	ecx
	mov	DWORD PTR _temp_size$[esp+1116], edi
	mov	DWORD PTR tv427[esp+1116], eax
	call	_A_memcpy

; 287  : 	A_memcpy(&temp_RdPtr[0],&this->RdPtr[0],temp_NrPtrs*sizeof (unsigned int));

	mov	edx, DWORD PTR tv427[esp+1116]
	lea	eax, DWORD PTR [ebx+80]
	push	edx
	push	eax
	mov	DWORD PTR tv429[esp+1124], eax
	lea	eax, DWORD PTR _temp_RdPtr$[esp+1124]
	push	eax
	call	_A_memcpy
	add	esp, 24					; 00000018H

; 288  : 
; 289  : 	//Buffer write actions
; 290  : 
; 291  : 	if (this->BufferType == RING)	//ringbuffer

	cmp	DWORD PTR [ebx+28], 1
	jne	$LN53@Write

; 292  : 	{
; 293  : 		for (unsigned int i=0;i<temp_NrPtrs;++i)	//check space requirements

	xor	eax, eax
	cmp	DWORD PTR _temp_NrPtrs$[esp+1104], eax
	jbe	SHORT $LN50@Write
$LN52@Write:

; 294  : 		{
; 295  : 			if(temp_QLoad[i] >= temp_size)

	mov	ecx, DWORD PTR _temp_QLoad$[esp+eax*4+1104]
	cmp	ecx, edi
	jae	SHORT $LN67@Write

; 300  : 				}
; 301  : 			if (w > (temp_size - temp_QLoad[i]))

	mov	edx, edi
	sub	edx, ecx
	cmp	DWORD PTR _w$[ebp], edx
	ja	SHORT $LN68@Write

; 292  : 	{
; 293  : 		for (unsigned int i=0;i<temp_NrPtrs;++i)	//check space requirements

	inc	eax
	cmp	eax, DWORD PTR _temp_NrPtrs$[esp+1104]
	jb	SHORT $LN52@Write
$LN50@Write:

; 306  : 				}
; 307  : 		}
; 308  : 
; 309  : 		unsigned int block;
; 310  : 		unsigned int offset=0;
; 311  : 		unsigned int w2 = w;	// Keep a copy of written bytes to update Read pointer(s) & Load(s)

	mov	ebx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _offset$30412[esp+1104], 0
	jmp	SHORT $LN47@Write
$LN67@Write:

; 296  : 				{
; 297  : 					this->OverFlow = 1;	// Set flag to inform that a write action could not be performed
; 298  : 					LeaveCriticalSection(&Crit1);

	mov	eax, DWORD PTR tv417[esp+1104]
	push	eax
	mov	DWORD PTR [ebx+40], 1
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 299  : 					return -2;	// One of the Ring buffers is completely full

	mov	eax, -2					; fffffffeH

; 460  : 	return 0;
; 461  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+1092]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN68@Write:

; 302  : 				{
; 303  : 					this->OverFlow = 1;	// Set flag to inform that a write action could not be performed
; 304  : 					LeaveCriticalSection(&Crit1);

	mov	ecx, DWORD PTR tv417[esp+1104]
	push	ecx
	mov	DWORD PTR [ebx+40], 1
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 305  : 					return -3;	// One of the Ring buffers lacks space to write all requested bytes

	mov	eax, -3					; fffffffdH

; 460  : 	return 0;
; 461  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+1092]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LL77@Write:

; 306  : 				}
; 307  : 		}
; 308  : 
; 309  : 		unsigned int block;
; 310  : 		unsigned int offset=0;
; 311  : 		unsigned int w2 = w;	// Keep a copy of written bytes to update Read pointer(s) & Load(s)

	mov	edi, DWORD PTR _temp_size$[esp+1104]
$LN47@Write:

; 314  : 		{
; 315  : 			block = temp_size - (temp_WrPtr+1);	// Get distance to Wrap point

	sub	edi, esi
	dec	edi

; 316  : 
; 317  : 			if (w2 <= BLOCKSIZE_WRITE || block <= BLOCKSIZE_WRITE)	// Byte-by-Byte Read

	cmp	ebx, 8
	jbe	SHORT $LN44@Write
	cmp	edi, 8
	jbe	SHORT $LN44@Write

; 329  : 				}
; 330  : 			}
; 331  : 			else	// Block Write		Max block write = size of requested bytes (if possible)
; 332  : 			{
; 333  : 				if (block > w2) block = w2;	// If more sequential space is available than requested amount, write requested amount (otherwise we have a memory (& pointer) overflow

	cmp	edi, ebx
	cmova	edi, ebx

; 334  : 				if (block >= 4096)
; 335  : 				{
; 336  : 					memcpy(&this->CQ[temp_WrPtr+1],d,block);

	push	edi
	cmp	edi, 4096				; 00001000H
	jb	SHORT $LN36@Write
	mov	eax, DWORD PTR _this$GSCopy$[esp+1108]
	mov	edx, DWORD PTR _d$GSCopy$[esp+1108]
	mov	ecx, DWORD PTR [eax+68]
	push	edx
	lea	edx, DWORD PTR [ecx+esi+1]
	push	edx
	call	_memcpy

; 337  : 				}
; 338  : 				else
; 339  : 				{
; 340  : 					A_memcpy(&this->CQ[temp_WrPtr+1],d,block);

	add	esp, 12					; 0000000cH

; 341  : 				}
; 342  : 				temp_WrPtr += block;

	add	esi, edi

; 343  : 				w2 -= block;	// Decrease nr of BytesToWrite

	sub	ebx, edi

; 344  : 				offset = block;	// offset = position to start for the Wrap write

	mov	DWORD PTR _offset$30412[esp+1104], edi
	jmp	SHORT $LN40@Write
$LN36@Write:

; 337  : 				}
; 338  : 				else
; 339  : 				{
; 340  : 					A_memcpy(&this->CQ[temp_WrPtr+1],d,block);

	mov	ecx, DWORD PTR _this$GSCopy$[esp+1108]
	mov	eax, DWORD PTR _d$GSCopy$[esp+1108]
	mov	edx, DWORD PTR [ecx+68]
	push	eax
	lea	eax, DWORD PTR [edx+esi+1]
	push	eax
	call	_A_memcpy
	add	esp, 12					; 0000000cH

; 341  : 				}
; 342  : 				temp_WrPtr += block;

	add	esi, edi

; 343  : 				w2 -= block;	// Decrease nr of BytesToWrite

	sub	ebx, edi

; 344  : 				offset = block;	// offset = position to start for the Wrap write

	mov	DWORD PTR _offset$30412[esp+1104], edi
	jmp	SHORT $LN40@Write
$LN44@Write:

; 318  : 			{	// When not much data to write, or we're close at the wrap point, write byte-per-byte
; 319  : 				unsigned int Small = w2;

	mov	ecx, ebx

; 320  : 
; 321  : 				if (Small > BLOCKSIZE_WRITE && (Small-block) > BLOCKSIZE_WRITE) Small = block+1;

	cmp	ebx, 8
	jbe	SHORT $LN43@Write
	mov	edx, ebx
	sub	edx, edi
	cmp	edx, 8
	jbe	SHORT $LN43@Write
	lea	ecx, DWORD PTR [edi+1]
$LN43@Write:

; 322  : 
; 323  : 				for (unsigned int i=0;i<Small;++i)

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN40@Write
	mov	edx, DWORD PTR _d$GSCopy$[esp+1104]
	add	edx, DWORD PTR _offset$30412[esp+1104]
	mov	DWORD PTR tv467[esp+1104], edx
$LN42@Write:

; 324  : 				{
; 325  : 					++temp_WrPtr;

	inc	esi

; 326  : 					if (temp_WrPtr == temp_size) temp_WrPtr = 0;	// inc + compare&set is 40% faster than modulus trick

	cmp	esi, DWORD PTR _temp_size$[esp+1104]
	jne	SHORT $LN39@Write
	xor	esi, esi
$LN39@Write:

; 327  : 					this->CQ[temp_WrPtr] = d[i+offset];

	mov	edx, DWORD PTR _this$GSCopy$[esp+1104]
	mov	edi, DWORD PTR tv467[esp+1104]
	mov	edx, DWORD PTR [edx+68]
	mov	DWORD PTR tv757[esp+1104], ecx
	mov	cl, BYTE PTR [edi+eax]
	mov	BYTE PTR [esi+edx], cl
	mov	ecx, DWORD PTR tv757[esp+1104]
	inc	eax

; 328  : 					--w2; //Decrease amount to write

	dec	ebx
	cmp	eax, ecx
	jb	SHORT $LN42@Write
$LN40@Write:

; 312  : 
; 313  : 		while (w2)

	test	ebx, ebx
	jne	$LL77@Write

; 345  : 			}
; 346  : 		}
; 347  : 		//Update Loads
; 348  : 		w -= w2;
; 349  : 		
; 350  : 		if (temp_NrPtrs > MINPTRS_FOR_SSE2 - 1)

	mov	ecx, DWORD PTR _temp_NrPtrs$[esp+1104]
	cmp	ecx, 3
	jbe	SHORT $LN34@Write

; 351  : 			{
; 352  : 				//Update Loads using SSE2
; 353  : 				const unsigned int SSEops = this->Amount_SSE2_Operations;

	mov	eax, DWORD PTR _this$GSCopy$[esp+1104]
	mov	ecx, DWORD PTR [eax+36]

; 354  : 				
; 355  : 				for (unsigned int q=0;q<SSEops;q+=4)

	xor	eax, eax
	test	ecx, ecx
	je	$LN26@Write

; 356  : 				{
; 357  : 					*(__m128i*)&temp_QLoad[q] = _mm_add_epi32(*(__m128i*)&temp_QLoad[q], _mm_set1_epi32 ((int)w));

	movd	xmm0, DWORD PTR _w$[ebp]
	pshufd	xmm0, xmm0, 0
	npad	10
$LL33@Write:
	movdqa	xmm1, XMMWORD PTR _temp_QLoad$[esp+eax*4+1104]
	paddd	xmm1, xmm0
	movdqa	XMMWORD PTR _temp_QLoad$[esp+eax*4+1104], xmm1
	add	eax, 4
	cmp	eax, ecx
	jb	SHORT $LL33@Write

; 358  : 				}
; 359  : 
; 360  : 			}
; 361  : 			else

	jmp	$LN26@Write
$LN34@Write:

; 362  : 			{	// Simple Update Loads if amount of Read Channels is too low to gain speed
; 363  : 				for (unsigned int q=0;q<temp_NrPtrs;++q)

	xor	eax, eax
	test	ecx, ecx
	je	$LN26@Write
$LL29@Write:

; 364  : 				{
; 365  : 					temp_QLoad[q] += w;	//Update loads

	mov	edx, DWORD PTR _w$[ebp]
	add	DWORD PTR _temp_QLoad$[esp+eax*4+1104], edx
	inc	eax
	cmp	eax, ecx
	jb	SHORT $LL29@Write

; 366  : 				}
; 367  : 			}
; 368  : 
; 369  : 	}
; 370  : 
; 371  : 	else	//FIFO

	jmp	$LN26@Write
$LN53@Write:

; 372  : 
; 373  : 	{
; 374  : 		unsigned int block;
; 375  : 		unsigned int offset=0;
; 376  : 		unsigned int w2 = w;	// Keep a copy of written bytes to update Read pointer(s) & Load(s)

	mov	ebx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _offset$30448[esp+1104], 0
	jmp	SHORT $LN25@Write
$LL78@Write:
	mov	edi, DWORD PTR _temp_size$[esp+1104]
$LN25@Write:

; 379  : 			{
; 380  : 				block = temp_size - (temp_WrPtr+1);	// Get distance to Wrap point

	sub	edi, esi
	dec	edi

; 381  : 
; 382  : 				if (w2 <= BLOCKSIZE_WRITE || block <= BLOCKSIZE_WRITE)	// Byte-by-Byte Read

	cmp	ebx, 8
	jbe	SHORT $LN22@Write
	cmp	edi, 8
	jbe	SHORT $LN22@Write

; 394  : 					}
; 395  : 				}
; 396  : 				else	// Block Write		Max block write = size of requested bytes (if possible)
; 397  : 				{
; 398  : 					if (block > w2) block = w2;	// If more sequential space is available than requested amount, write requested amount (otherwise we have a memory (& pointer) overflow

	cmp	edi, ebx
	cmova	edi, ebx

; 399  : 					if (block >= 4096)
; 400  : 					{
; 401  : 						memcpy(&this->CQ[temp_WrPtr+1],d,block);	//Microsoft memcpy is faster >4k blocks

	push	edi
	cmp	edi, 4096				; 00001000H
	jb	SHORT $LN14@Write
	mov	ecx, DWORD PTR _this$GSCopy$[esp+1108]
	mov	eax, DWORD PTR _d$GSCopy$[esp+1108]
	mov	edx, DWORD PTR [ecx+68]
	push	eax
	lea	eax, DWORD PTR [edx+esi+1]
	push	eax
	call	_memcpy

; 402  : 					}
; 403  : 					else
; 404  : 					{
; 405  : 						A_memcpy(&this->CQ[temp_WrPtr+1],d,block);	//Agner Fog's lib is A LOT faster <4k blocks

	add	esp, 12					; 0000000cH

; 406  : 					}
; 407  : 					temp_WrPtr += block;

	add	esi, edi

; 408  : 					w2 -= block;	// Decrease nr of BytesToWrite

	sub	ebx, edi

; 409  : 					offset = block;	// offset = position to start for the Wrap write

	mov	DWORD PTR _offset$30448[esp+1104], edi
	jmp	SHORT $LN18@Write
$LN14@Write:

; 402  : 					}
; 403  : 					else
; 404  : 					{
; 405  : 						A_memcpy(&this->CQ[temp_WrPtr+1],d,block);	//Agner Fog's lib is A LOT faster <4k blocks

	mov	edx, DWORD PTR _this$GSCopy$[esp+1108]
	mov	ecx, DWORD PTR _d$GSCopy$[esp+1108]
	mov	eax, DWORD PTR [edx+68]
	push	ecx
	lea	ecx, DWORD PTR [eax+esi+1]
	push	ecx
	call	_A_memcpy
	add	esp, 12					; 0000000cH

; 406  : 					}
; 407  : 					temp_WrPtr += block;

	add	esi, edi

; 408  : 					w2 -= block;	// Decrease nr of BytesToWrite

	sub	ebx, edi

; 409  : 					offset = block;	// offset = position to start for the Wrap write

	mov	DWORD PTR _offset$30448[esp+1104], edi
	jmp	SHORT $LN18@Write
$LN22@Write:

; 383  : 				{	// When not much data to write, or we're close at the wrap point, write byte-per-byte
; 384  : 					unsigned int Small = w2;

	mov	ecx, ebx

; 385  : 
; 386  : 					if (Small > BLOCKSIZE_WRITE && (Small-block) > BLOCKSIZE_WRITE) Small = block+1;

	cmp	ebx, 8
	jbe	SHORT $LN21@Write
	mov	edx, ebx
	sub	edx, edi
	cmp	edx, 8
	jbe	SHORT $LN21@Write
	lea	ecx, DWORD PTR [edi+1]
$LN21@Write:

; 387  : 
; 388  : 					for (unsigned int i=0;i<Small;++i)

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN18@Write
	mov	edx, DWORD PTR _d$GSCopy$[esp+1104]
	add	edx, DWORD PTR _offset$30448[esp+1104]
	mov	DWORD PTR tv510[esp+1104], edx
$LN20@Write:

; 389  : 					{
; 390  : 						++temp_WrPtr;

	inc	esi

; 391  : 						if (temp_WrPtr == temp_size) temp_WrPtr = 0;	// inc + compare&set is 40% faster than modulus trick

	cmp	esi, DWORD PTR _temp_size$[esp+1104]
	jne	SHORT $LN17@Write
	xor	esi, esi
$LN17@Write:

; 392  : 						this->CQ[temp_WrPtr] = d[i+offset];

	mov	edx, DWORD PTR _this$GSCopy$[esp+1104]
	mov	edi, DWORD PTR tv510[esp+1104]
	mov	edx, DWORD PTR [edx+68]
	mov	DWORD PTR tv756[esp+1104], ecx
	mov	cl, BYTE PTR [edi+eax]
	mov	BYTE PTR [esi+edx], cl
	mov	ecx, DWORD PTR tv756[esp+1104]
	inc	eax

; 393  : 						--w2;

	dec	ebx
	cmp	eax, ecx
	jb	SHORT $LN20@Write
$LN18@Write:

; 377  : 		
; 378  : 			while (w2)

	test	ebx, ebx
	jne	$LL78@Write

; 410  : 				}
; 411  : 			}
; 412  : 			
; 413  : 			//Update Loads
; 414  : 			w -= w2;	//Update w to actual written amount
; 415  : 						
; 416  : 			if (temp_NrPtrs >= MINPTRS_FOR_SSE2)

	mov	edi, DWORD PTR _temp_NrPtrs$[esp+1104]
	cmp	edi, 4
	jb	SHORT $LN12@Write

; 417  : 			{
; 418  : 				//Update Loads using SSE2
; 419  : 				const unsigned int SSEops = this->Amount_SSE2_Operations;

	mov	eax, DWORD PTR _this$GSCopy$[esp+1104]
	mov	ecx, DWORD PTR [eax+36]

; 420  : 				
; 421  : 				for (unsigned int q=0;q<SSEops;q+=4)	//Update 4 Loads at a time

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN5@Write

; 422  : 				{
; 423  : 					*(__m128i*)&temp_QLoad[q] = _mm_add_epi32(*(__m128i*)&temp_QLoad[q], _mm_set1_epi32 ((int)w));

	movd	xmm0, DWORD PTR _w$[ebp]
	pshufd	xmm0, xmm0, 0
	npad	2
$LL11@Write:
	movdqa	xmm1, XMMWORD PTR _temp_QLoad$[esp+eax*4+1104]
	paddd	xmm1, xmm0
	movdqa	XMMWORD PTR _temp_QLoad$[esp+eax*4+1104], xmm1
	add	eax, 4
	cmp	eax, ecx
	jb	SHORT $LL11@Write

; 424  : 				}
; 425  : 
; 426  : 			}
; 427  : 			else

	jmp	SHORT $LN5@Write
$LN12@Write:

; 428  : 			{	// Simple Update Loads if amount of Read Channels is too low to gain speed
; 429  : 				for (unsigned int q=0;q<temp_NrPtrs;++q)

	xor	eax, eax
	test	edi, edi
	je	SHORT $LN5@Write
	npad	1
$LL7@Write:

; 430  : 				{
; 431  : 					temp_QLoad[q] += w;	//Update loads

	mov	ecx, DWORD PTR _w$[ebp]
	add	DWORD PTR _temp_QLoad$[esp+eax*4+1104], ecx
	inc	eax
	cmp	eax, edi
	jb	SHORT $LL7@Write
$LN5@Write:

; 432  : 				}
; 433  : 			}
; 434  : 
; 435  : 			// Update Pointers & Check Overflow
; 436  : 			unsigned int CacheCopy_OverFlow = 0;

	xor	edx, edx

; 437  : 
; 438  : 			for (unsigned int q=0;q<temp_NrPtrs;++q)

	xor	eax, eax
	test	edi, edi
	je	SHORT $LN2@Write
$LL4@Write:

; 439  : 			{	
; 440  : 				if (temp_QLoad[q] > temp_size)	// New Load is larger/equal then/to queue size

	mov	ecx, DWORD PTR _temp_size$[esp+1104]
	cmp	DWORD PTR _temp_QLoad$[esp+eax*4+1104], ecx
	jbe	SHORT $LN3@Write

; 441  : 				{
; 442  : 					temp_QLoad[q] = temp_size; // Max. possible amount is queue size

	mov	DWORD PTR _temp_QLoad$[esp+eax*4+1104], ecx

; 443  : 					temp_RdPtr[q] = temp_WrPtr; // Pointers are equal when buffer is full

	mov	DWORD PTR _temp_RdPtr$[esp+eax*4+1104], esi

; 444  : 					CacheCopy_OverFlow = 1; //If new amount of data is larger then the queue, we lost data ..

	mov	edx, 1
$LN3@Write:

; 437  : 
; 438  : 			for (unsigned int q=0;q<temp_NrPtrs;++q)

	inc	eax
	cmp	eax, edi
	jb	SHORT $LL4@Write
$LN2@Write:

; 445  : 				}
; 446  : 			}
; 447  : 
; 448  : 			this->OverFlow = CacheCopy_OverFlow;

	mov	eax, DWORD PTR _this$GSCopy$[esp+1104]
	mov	DWORD PTR [eax+40], edx
$LN26@Write:

; 449  : 	}
; 450  : 
; 451  : 	// Write back changed value's to RAM
; 452  : 	this->WrPtr = temp_WrPtr;

	mov	ecx, DWORD PTR _this$GSCopy$[esp+1104]

; 453  : 
; 454  : 	A_memcpy(&this->QLoad[0], &temp_QLoad[0], temp_NrPtrs*sizeof (unsigned int));

	mov	eax, DWORD PTR tv428[esp+1104]
	mov	DWORD PTR [ecx+24], esi
	mov	esi, DWORD PTR tv427[esp+1104]
	push	esi
	lea	edx, DWORD PTR _temp_QLoad$[esp+1108]
	push	edx
	push	eax
	call	_A_memcpy

; 455  : 	A_memcpy(&this->RdPtr[0], &temp_RdPtr[0], temp_NrPtrs*sizeof (unsigned int));

	mov	edx, DWORD PTR tv429[esp+1116]
	push	esi
	lea	ecx, DWORD PTR _temp_RdPtr$[esp+1120]
	push	ecx
	push	edx
	call	_A_memcpy

; 456  : 
; 457  : 
; 458  : 	// Exit
; 459  : 	LeaveCriticalSection(&Crit1);

	mov	eax, DWORD PTR tv417[esp+1128]
	add	esp, 24					; 00000018H
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 460  : 	return 0;
; 461  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+1104]
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	xor	eax, eax
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Write@Buffers@@QAEHIPAE@Z ENDP				; Buffers::Write
_TEXT	ENDS
PUBLIC	?Read@Buffers@@QAEHIIPAE@Z			; Buffers::Read
; Function compile flags: /Ogtpy
;	COMDAT ?Read@Buffers@@QAEHIIPAE@Z
_TEXT	SEGMENT
_temp_size$ = -8					; size = 4
tv229 = -4						; size = 4
_offset$ = 8						; size = 4
_this$ = 8						; size = 4
_NrPtr$ = 12						; size = 4
_temp_QLoad$ = 16					; size = 4
_r$ = 16						; size = 4
_d$ = 20						; size = 4
?Read@Buffers@@QAEHIIPAE@Z PROC				; Buffers::Read, COMDAT

; 200  : {

	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR _r$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+12]
	push	esi

; 201  : 	if (NrPtr >= this->NrPtrs) return -1;	// Invalid pointer

	mov	esi, DWORD PTR _NrPtr$[esp+16]
	cmp	esi, DWORD PTR [ebp+32]
	jb	SHORT $LN17@Read
	pop	esi
	pop	ebp
	or	eax, -1
	pop	ebx

; 271  : }

	add	esp, 8
	ret	16					; 00000010H
$LN17@Read:

; 202  : 
; 203  : 	if (!r) return -2;	// A minimum of 1 byte should be requested

	test	ebx, ebx
	jne	SHORT $LN16@Read
	pop	esi
	pop	ebp
	lea	eax, DWORD PTR [ebx-2]
	pop	ebx

; 271  : }

	add	esp, 8
	ret	16					; 00000010H
$LN16@Read:
	push	edi

; 204  : 
; 205  : 	EnterCriticalSection(&Crit1);

	lea	edi, DWORD PTR [ebp+44]
	push	edi
	mov	DWORD PTR tv229[esp+28], edi
	call	DWORD PTR __imp__EnterCriticalSection@4

; 206  : 
; 207  : 	if (!this->QLoad[NrPtr])

	mov	eax, DWORD PTR [ebp+esi*4+592]
	test	eax, eax
	jne	SHORT $LN15@Read

; 208  : 		{
; 209  : 			LeaveCriticalSection(&Crit1);

	push	edi
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	edi
	pop	esi
	pop	ebp

; 210  : 			return -3;	//Queue is empty

	mov	eax, -3					; fffffffdH
	pop	ebx

; 271  : }

	add	esp, 8
	ret	16					; 00000010H
$LN15@Read:

; 211  : 		}
; 212  : 	if (r > this->QLoad[NrPtr])

	cmp	ebx, eax
	jbe	SHORT $LN14@Read

; 213  : 		{
; 214  : 			LeaveCriticalSection(&Crit1);

	push	edi
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	edi
	pop	esi
	pop	ebp

; 215  : 			return -4;	//Requested amount of bytes is higher than nr of available bytes

	mov	eax, -4					; fffffffcH
	pop	ebx

; 271  : }

	add	esp, 8
	ret	16					; 00000010H
$LN14@Read:

; 216  : 		}
; 217  : 	
; 218  : 	//copy class vars to locals for caching reasons (96% Speed increase)
; 219  : 	const unsigned int temp_size = this->size;

	mov	ecx, DWORD PTR [ebp+20]

; 220  : 	unsigned int block;	//Space to Wrap point
; 221  : 	unsigned int offset=0;	//Unfinished block indicator + starting point indicator
; 222  : 	unsigned int temp_RdPtr = this->RdPtr[NrPtr];

	mov	edi, DWORD PTR [ebp+esi*4+80]
	mov	DWORD PTR _temp_size$[esp+24], ecx
	mov	DWORD PTR _offset$[esp+20], 0

; 223  : 	unsigned int temp_QLoad = this->QLoad[NrPtr];

	mov	DWORD PTR _temp_QLoad$[esp+20], eax
$LL13@Read:

; 227  : 	{
; 228  : 		block = temp_size - (temp_RdPtr+1);	// Get distance to Wrap point

	mov	esi, DWORD PTR _temp_size$[esp+24]
	sub	esi, edi
	dec	esi

; 229  : 
; 230  : 		if (r <= BLOCKSIZE_READ || block <= BLOCKSIZE_READ)	// Byte-by-Byte Read

	cmp	ebx, 8
	jbe	SHORT $LN10@Read
	cmp	esi, 8
	jbe	SHORT $LN10@Read

; 244  : 			}
; 245  : 		}
; 246  : 		else	// Block Read		Max block read = size of requested bytes (if possible)
; 247  : 		{
; 248  : 			if (block > r) block = r;	// If more sequential space is available than requested amount, write amount left
; 249  : 			if (block >= 4096)
; 250  : 			{
; 251  : 				memcpy(d,&this->CQ[temp_RdPtr+1],block);	//Microsoft memcpy is faster >4k blocks

	mov	edx, DWORD PTR [ebp+68]
	mov	ecx, DWORD PTR _d$[esp+20]
	cmp	esi, ebx
	cmova	esi, ebx
	push	esi
	lea	eax, DWORD PTR [edx+edi+1]
	push	eax
	push	ecx
	cmp	esi, 4096				; 00001000H
	jb	SHORT $LN2@Read
	call	_memcpy

; 256  : 			}
; 257  : 			temp_RdPtr += block;
; 258  : 			temp_QLoad -=block;

	sub	DWORD PTR _temp_QLoad$[esp+32], esi
	add	esp, 12					; 0000000cH
	add	edi, esi

; 259  : 			r -= block;	// Decrease nr of BytesToRead

	sub	ebx, esi

; 260  : 			offset = block;	// offset = position to start for the Wrap write

	mov	DWORD PTR _offset$[esp+20], esi
	jmp	SHORT $LN6@Read
$LN2@Read:

; 252  : 			}
; 253  : 			else
; 254  : 			{
; 255  : 				A_memcpy(d,&this->CQ[temp_RdPtr+1],block);	//Agner Fog's lib is !A LOT! faster <4k blocks

	call	_A_memcpy

; 256  : 			}
; 257  : 			temp_RdPtr += block;
; 258  : 			temp_QLoad -=block;

	sub	DWORD PTR _temp_QLoad$[esp+32], esi
	add	esp, 12					; 0000000cH
	add	edi, esi

; 259  : 			r -= block;	// Decrease nr of BytesToRead

	sub	ebx, esi

; 260  : 			offset = block;	// offset = position to start for the Wrap write

	mov	DWORD PTR _offset$[esp+20], esi
	jmp	SHORT $LN6@Read
$LN10@Read:

; 231  : 		{	// When not much data to write, or we're close at the wrap point, write byte-per-byte
; 232  : 			unsigned int Small = r;

	mov	ecx, ebx

; 233  : 
; 234  : 			if (Small > BLOCKSIZE_READ && (Small-block) > BLOCKSIZE_READ) Small = block+1;

	cmp	ebx, 8
	jbe	SHORT $LN9@Read
	mov	edx, ebx
	sub	edx, esi
	cmp	edx, 8
	jbe	SHORT $LN9@Read
	lea	ecx, DWORD PTR [esi+1]
$LN9@Read:

; 235  : 			//If the reason for BbB is "Close at Wrap", read just behind the wrap & re-evaluate if we can blockread again
; 236  : 			
; 237  : 			for (unsigned int i=0;i<Small;++i)

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN6@Read
	mov	esi, DWORD PTR _offset$[esp+20]
	add	esi, DWORD PTR _d$[esp+20]
	npad	3
$LL8@Read:

; 238  : 			{
; 239  : 				++temp_RdPtr;

	inc	edi

; 240  : 				if (temp_RdPtr == temp_size) temp_RdPtr = 0;	// Make it circular

	cmp	edi, DWORD PTR _temp_size$[esp+24]
	jne	SHORT $LN5@Read
	xor	edi, edi
$LN5@Read:

; 241  : 				d[i+offset] = this->CQ[temp_RdPtr];

	mov	edx, DWORD PTR [ebp+68]
	mov	dl, BYTE PTR [edi+edx]

; 242  : 				--r;
; 243  : 				--temp_QLoad;

	dec	DWORD PTR _temp_QLoad$[esp+20]
	mov	BYTE PTR [esi+eax], dl
	inc	eax
	dec	ebx
	cmp	eax, ecx
	jb	SHORT $LL8@Read
$LN6@Read:

; 224  : 
; 225  : 	//read from buff
; 226  : 	while(r)	// Loop until all bytes have been read

	test	ebx, ebx
	jne	$LL13@Read

; 261  : 		}
; 262  : 	}
; 263  : 
; 264  : 	//Save changes
; 265  : 	this->RdPtr[NrPtr] = temp_RdPtr;

	mov	eax, DWORD PTR _NrPtr$[esp+20]

; 266  : 	this->QLoad[NrPtr] = temp_QLoad;
; 267  : 
; 268  : 	LeaveCriticalSection(&Crit1);

	mov	edx, DWORD PTR tv229[esp+24]
	mov	ecx, DWORD PTR _temp_QLoad$[esp+20]
	push	edx
	mov	DWORD PTR [ebp+eax*4+80], edi
	mov	DWORD PTR [ebp+eax*4+592], ecx
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	edi
	pop	esi
	pop	ebp

; 269  : 
; 270  : 	return 0;

	xor	eax, eax
	pop	ebx

; 271  : }

	add	esp, 8
	ret	16					; 00000010H
?Read@Buffers@@QAEHIIPAE@Z ENDP				; Buffers::Read
_TEXT	ENDS
PUBLIC	?CreateQueue@Buffers@@AAEHI@Z			; Buffers::CreateQueue
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CreateQueue@Buffers@@AAEHI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?CreateQueue@Buffers@@AAEHI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?CreateQueue@Buffers@@AAEHI@Z$0
__tryblocktable$?CreateQueue@Buffers@@AAEHI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?CreateQueue@Buffers@@AAEHI@Z$2
__ehfuncinfo$?CreateQueue@Buffers@@AAEHI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CreateQueue@Buffers@@AAEHI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?CreateQueue@Buffers@@AAEHI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?CreateQueue@Buffers@@AAEHI@Z
_TEXT	SEGMENT
$T30955 = -20						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
_size$ = 12						; size = 4
?CreateQueue@Buffers@@AAEHI@Z PROC			; Buffers::CreateQueue, COMDAT

; 178  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateQueue@Buffers@@AAEHI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 179  : #ifdef __ALIGNED__
; 180  : 	this->CQ = (unsigned char*) _mm_malloc(size,64);
; 181  : 	if (!this->CQ) return -1;
; 182  : #else
; 183  : 	try
; 184  : 	{
; 185  : 		this->CQ = new unsigned char[size];

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	DWORD PTR __imp_??2@YAPAXI@Z
	mov	ecx, DWORD PTR _this$[ebp]
	add	esp, 4
	mov	DWORD PTR [ecx+68], eax

; 186  : 		if (!this->CQ) throw -1;

	test	eax, eax
	jne	SHORT $LN1@CreateQueu
	push	OFFSET __TI1H
	lea	edx, DWORD PTR $T30955[ebp]
	push	edx
	mov	DWORD PTR $T30955[ebp], -1
	call	__CxxThrowException@8
$LN12@CreateQueu:
$LN1@CreateQueu:

; 194  : 	}
; 195  : #endif
; 196  : 	return 0;

	xor	eax, eax

; 197  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?CreateQueue@Buffers@@AAEHI@Z$0:

; 187  : 	}
; 188  : 
; 189  : 	catch (...)
; 190  : 	{
; 191  : 		this->CQ = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 192  : 		this->QueueError = true;

	mov	BYTE PTR [eax+16], 1

; 193  : 		return -1;

	mov	eax, $LN8@CreateQueu
	ret	0
$LN8@CreateQueu:
	or	eax, -1

; 197  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN11@CreateQueu:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?CreateQueue@Buffers@@AAEHI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CreateQueue@Buffers@@AAEHI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateQueue@Buffers@@AAEHI@Z ENDP			; Buffers::CreateQueue
PUBLIC	?Flush@Buffers@@QAEXH@Z				; Buffers::Flush
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Flush@Buffers@@QAEXH@Z
_TEXT	SEGMENT
?Flush@Buffers@@QAEXH@Z PROC				; Buffers::Flush, COMDAT
; _this$ = ecx
; _NrPtr$ = eax

; 151  : {

	push	esi
	push	edi
	mov	edi, eax
	mov	esi, ecx

; 152  : 	if (NrPtr >= (int)this->NrPtrs) return;	// Invalid pointer

	cmp	edi, DWORD PTR [esi+32]
	jge	SHORT $LN7@Flush

; 153  : 
; 154  : 	EnterCriticalSection(&Crit1);

	push	ebx
	lea	ebx, DWORD PTR [esi+44]
	push	ebx
	call	DWORD PTR __imp__EnterCriticalSection@4

; 155  : 	if (NrPtr == -1)	// If -1 is received, reset all pointers

	cmp	edi, -1
	jne	SHORT $LN5@Flush

; 156  : 		{
; 157  : 			const unsigned int CacheCopy_NrPtrs = this->NrPtrs;

	mov	ecx, DWORD PTR [esi+32]

; 158  : 			unsigned int CacheCopy_WrPtr = this->WrPtr;

	mov	eax, DWORD PTR [esi+24]

; 159  : 
; 160  : 			for (unsigned int i=0;i<CacheCopy_NrPtrs;++i)

	test	ecx, ecx
	je	SHORT $LN4@Flush

; 156  : 		{
; 157  : 			const unsigned int CacheCopy_NrPtrs = this->NrPtrs;

	lea	edi, DWORD PTR [esi+80]
	rep stosd
$LN4@Flush:

; 161  : 			{
; 162  : 				this->RdPtr[i] = CacheCopy_WrPtr;
; 163  : 			}
; 164  : 
; 165  : 			memset(&this->QLoad[0],0, this->NrPtrs * sizeof (unsigned int));

	mov	eax, DWORD PTR [esi+32]
	add	eax, eax
	add	eax, eax
	push	eax
	push	0
	add	esi, 592				; 00000250H
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 171  : 			this->QLoad[NrPtr] = 0;
; 172  : 		}
; 173  : 		
; 174  : 	LeaveCriticalSection(&Crit1);

	push	ebx
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	ebx
	pop	edi
	pop	esi

; 175  : }

	ret	0
$LN5@Flush:

; 166  : 
; 167  : 		}
; 168  : 	else
; 169  : 		{
; 170  : 			this->RdPtr[NrPtr]=this->WrPtr;

	mov	ecx, DWORD PTR [esi+24]

; 171  : 			this->QLoad[NrPtr] = 0;
; 172  : 		}
; 173  : 		
; 174  : 	LeaveCriticalSection(&Crit1);

	push	ebx
	mov	DWORD PTR [esi+edi*4+80], ecx
	mov	DWORD PTR [esi+edi*4+592], 0
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	ebx
$LN7@Flush:

; 175  : }

	pop	edi
	pop	esi
	ret	0
?Flush@Buffers@@QAEXH@Z ENDP				; Buffers::Flush
_TEXT	ENDS
PUBLIC	?QLoaded@Buffers@@QAEII@Z			; Buffers::QLoaded
; Function compile flags: /Ogtpy
;	COMDAT ?QLoaded@Buffers@@QAEII@Z
_TEXT	SEGMENT
_NrPtr$ = 8						; size = 4
?QLoaded@Buffers@@QAEII@Z PROC				; Buffers::QLoaded, COMDAT
; _this$ = eax

; 138  : {

	push	ebx
	mov	ebx, DWORD PTR _NrPtr$[esp]
	push	edi
	mov	edi, eax

; 139  : 	unsigned int k=0;
; 140  : 
; 141  : 	if (NrPtr >= this->NrPtrs) return 0;	// Invalid pointer

	cmp	ebx, DWORD PTR [edi+32]
	jb	SHORT $LN1@QLoaded
	pop	edi
	xor	eax, eax
	pop	ebx

; 148  : }

	ret	4
$LN1@QLoaded:
	push	esi

; 142  : 
; 143  : 	EnterCriticalSection(&Crit1);

	lea	esi, DWORD PTR [edi+44]
	push	esi
	call	DWORD PTR __imp__EnterCriticalSection@4

; 144  : 		k = this->QLoad[NrPtr];	

	mov	edi, DWORD PTR [edi+ebx*4+592]

; 145  : 	LeaveCriticalSection(&Crit1);

	push	esi
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	esi

; 146  : 	
; 147  : 	return k;

	mov	eax, edi
	pop	edi
	pop	ebx

; 148  : }

	ret	4
?QLoaded@Buffers@@QAEII@Z ENDP				; Buffers::QLoaded
_TEXT	ENDS
PUBLIC	?QFree@Buffers@@QAEII@Z				; Buffers::QFree
; Function compile flags: /Ogtpy
;	COMDAT ?QFree@Buffers@@QAEII@Z
_TEXT	SEGMENT
_NrPtr$ = 8						; size = 4
?QFree@Buffers@@QAEII@Z PROC				; Buffers::QFree, COMDAT
; _this$ = edi

; 125  : {

	push	ebp
	mov	ebp, DWORD PTR _NrPtr$[esp]

; 126  : 	unsigned int k=0;
; 127  : 
; 128  : 	if (NrPtr >= this->NrPtrs) return 0;	// Invalid pointer

	cmp	ebp, DWORD PTR [edi+32]
	jb	SHORT $LN1@QFree
	xor	eax, eax
	pop	ebp

; 135  : }

	ret	4
$LN1@QFree:
	push	ebx
	push	esi

; 129  : 
; 130  : 	EnterCriticalSection(&Crit1);

	lea	ebx, DWORD PTR [edi+44]
	push	ebx
	call	DWORD PTR __imp__EnterCriticalSection@4

; 131  : 		k = (this->size - this->QLoad[NrPtr]); // k is needed to give the function a chance to release the lock first before returning

	mov	esi, DWORD PTR [edi+20]
	sub	esi, DWORD PTR [edi+ebp*4+592]

; 132  : 	LeaveCriticalSection(&Crit1);

	push	ebx
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 133  : 	
; 134  : 	return k;

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 135  : }

	ret	4
?QFree@Buffers@@QAEII@Z ENDP				; Buffers::QFree
_TEXT	ENDS
PUBLIC	??1Buffers@@UAE@XZ				; Buffers::~Buffers
; Function compile flags: /Ogtpy
;	COMDAT ??1Buffers@@UAE@XZ
_TEXT	SEGMENT
??1Buffers@@UAE@XZ PROC					; Buffers::~Buffers, COMDAT
; _this$ = ecx

; 113  : {

	push	esi
	mov	esi, ecx

; 114  : 	DeleteCriticalSection(&Crit1);

	lea	eax, DWORD PTR [esi+44]
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7Buffers@@6B@
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 115  : #ifdef __ALIGNED__
; 116  : 	if (this->CQ) _mm_free(this->CQ);
; 117  : #else
; 118  : 	if (this->CQ) delete []this->CQ;

	mov	eax, DWORD PTR [esi+68]
	test	eax, eax
	je	SHORT $LN4@Buffers
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN4@Buffers:

; 119  : #endif
; 120  : 	this->CQ = nullptr;

	mov	DWORD PTR [esi+68], 0
	pop	esi

; 121  : }

	ret	0
??1Buffers@@UAE@XZ ENDP					; Buffers::~Buffers
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GBuffers@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GBuffers@@UAEPAXI@Z PROC				; Buffers::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	edi
	lea	eax, DWORD PTR [esi+44]
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7Buffers@@6B@
	call	DWORD PTR __imp__DeleteCriticalSection@4
	mov	eax, DWORD PTR [esi+68]
	mov	edi, DWORD PTR __imp_??3@YAXPAX@Z
	test	eax, eax
	je	SHORT $LN4@scalar
	push	eax
	call	edi
	add	esp, 4
$LN4@scalar:
	test	BYTE PTR ___flags$[esp+4], 1
	mov	DWORD PTR [esi+68], 0
	je	SHORT $LN7@scalar
	push	esi
	call	edi
	add	esp, 4
$LN7@scalar:
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??_GBuffers@@UAEPAXI@Z ENDP				; Buffers::`scalar deleting destructor'
PUBLIC	_BufferClearOverflow_Wait@4
; Function compile flags: /Ogtpy
;	COMDAT _BufferClearOverflow_Wait@4
_TEXT	SEGMENT
_buffer_nr$ = 8						; size = 4
_BufferClearOverflow_Wait@4 PROC			; COMDAT

; 599  : {

	push	esi
	push	edi

; 600  : 	Buffers * incoming = (Buffers*) buffer_nr;
; 601  : 	incoming->StatusClearOverFlow();

	mov	edi, DWORD PTR _buffer_nr$[esp+4]
	lea	esi, DWORD PTR [edi+44]
	push	esi
	call	DWORD PTR __imp__EnterCriticalSection@4
	push	esi
	mov	DWORD PTR [edi+40], 0
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	edi
	pop	esi

; 602  : }

	ret	4
_BufferClearOverflow_Wait@4 ENDP
_TEXT	ENDS
PUBLIC	_BufferGetOverflow_Wait@4
; Function compile flags: /Ogtpy
;	COMDAT _BufferGetOverflow_Wait@4
_TEXT	SEGMENT
_buffer_nr$ = 8						; size = 4
_BufferGetOverflow_Wait@4 PROC				; COMDAT

; 593  : {

	push	esi
	push	edi

; 594  : 	Buffers * incoming = (Buffers*) buffer_nr;
; 595  : 	return incoming->StatusGetOverFlow();

	mov	edi, DWORD PTR _buffer_nr$[esp+4]
	lea	esi, DWORD PTR [edi+44]
	push	esi
	call	DWORD PTR __imp__EnterCriticalSection@4
	mov	edi, DWORD PTR [edi+40]
	push	esi
	call	DWORD PTR __imp__LeaveCriticalSection@4
	mov	eax, edi
	pop	edi
	pop	esi

; 596  : }

	ret	4
_BufferGetOverflow_Wait@4 ENDP
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	__real@41f0000000000000
PUBLIC	_BufferSpaceUsed_Percentage@8
EXTRN	__fltused:DWORD
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _BufferSpaceUsed_Percentage@8
_TEXT	SEGMENT
_buffer_nr$ = 8						; size = 4
tv183 = 12						; size = 4
tv179 = 12						; size = 4
_ReadChannel$ = 12					; size = 4
_BufferSpaceUsed_Percentage@8 PROC			; COMDAT

; 585  : {

	push	ebx

; 586  : 	double k =0;
; 587  : 	Buffers * incoming = (Buffers*) buffer_nr;
; 588  : 	k = ((double)incoming->QLoaded(ReadChannel) / (double)incoming->CQsize())*100;

	mov	ebx, DWORD PTR _ReadChannel$[esp]
	push	edi
	mov	edi, DWORD PTR _buffer_nr$[esp+4]
	cmp	ebx, DWORD PTR [edi+32]
	jb	SHORT $LN3@BufferSpac
	xor	ebx, ebx
	jmp	SHORT $LN4@BufferSpac
$LN3@BufferSpac:
	push	esi
	lea	esi, DWORD PTR [edi+44]
	push	esi
	call	DWORD PTR __imp__EnterCriticalSection@4
	mov	ebx, DWORD PTR [edi+ebx*4+592]
	push	esi
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	esi
$LN4@BufferSpac:

; 589  : 	return  k;

	mov	DWORD PTR tv183[esp+4], ebx
	fild	DWORD PTR tv183[esp+4]
	test	ebx, ebx
	jns	SHORT $LN8@BufferSpac
	fadd	QWORD PTR __real@41f0000000000000
$LN8@BufferSpac:
	mov	eax, DWORD PTR [edi+20]
	fild	DWORD PTR [edi+20]
	test	eax, eax
	jns	SHORT $LN9@BufferSpac
	fadd	QWORD PTR __real@41f0000000000000
$LN9@BufferSpac:

; 586  : 	double k =0;
; 587  : 	Buffers * incoming = (Buffers*) buffer_nr;
; 588  : 	k = ((double)incoming->QLoaded(ReadChannel) / (double)incoming->CQsize())*100;

	fdivp	ST(1), ST(0)
	pop	edi
	pop	ebx
	fmul	QWORD PTR __real@4059000000000000

; 590  : }

	ret	8
_BufferSpaceUsed_Percentage@8 ENDP
_TEXT	ENDS
PUBLIC	_BufferSpaceUsed@8
; Function compile flags: /Ogtpy
;	COMDAT _BufferSpaceUsed@8
_TEXT	SEGMENT
_buffer_nr$ = 8						; size = 4
_ReadChannel$ = 12					; size = 4
_BufferSpaceUsed@8 PROC					; COMDAT

; 579  : {

	push	ebx

; 580  : 	Buffers * incoming = (Buffers*) buffer_nr;
; 581  : 	return incoming->QLoaded(ReadChannel);

	mov	ebx, DWORD PTR _ReadChannel$[esp]
	push	edi
	mov	edi, DWORD PTR _buffer_nr$[esp+4]
	cmp	ebx, DWORD PTR [edi+32]
	jb	SHORT $LN3@BufferSpac@2
	pop	edi
	xor	eax, eax
	pop	ebx

; 582  : }

	ret	8

; 580  : 	Buffers * incoming = (Buffers*) buffer_nr;
; 581  : 	return incoming->QLoaded(ReadChannel);

$LN3@BufferSpac@2:
	push	esi
	lea	esi, DWORD PTR [edi+44]
	push	esi
	call	DWORD PTR __imp__EnterCriticalSection@4
	mov	edi, DWORD PTR [edi+ebx*4+592]
	push	esi
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	esi
	mov	eax, edi
	pop	edi
	pop	ebx

; 582  : }

	ret	8
_BufferSpaceUsed@8 ENDP
_TEXT	ENDS
PUBLIC	_BufferSpaceAvailable_Percentage@8
; Function compile flags: /Ogtpy
;	COMDAT _BufferSpaceAvailable_Percentage@8
_TEXT	SEGMENT
_buffer_nr$ = 8						; size = 4
tv219 = 12						; size = 4
tv215 = 12						; size = 4
_ReadChannel$ = 12					; size = 4
_BufferSpaceAvailable_Percentage@8 PROC			; COMDAT

; 565  : {

	push	ebp

; 566  : 	unsigned int a =0;
; 567  : 	double k =0;
; 568  : 	Buffers * incoming = (Buffers*) buffer_nr;
; 569  : 	a = incoming->QFree(ReadChannel);

	mov	ebp, DWORD PTR _ReadChannel$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _buffer_nr$[esp+8]
	cmp	ebp, DWORD PTR [edi+32]
	jb	SHORT $LN4@BufferSpac@3
	xor	esi, esi
	jmp	SHORT $LN1@BufferSpac@3
$LN4@BufferSpac@3:
	push	ebx
	lea	ebx, DWORD PTR [edi+44]
	push	ebx
	call	DWORD PTR __imp__EnterCriticalSection@4
	mov	esi, DWORD PTR [edi+20]
	sub	esi, DWORD PTR [edi+ebp*4+592]
	push	ebx
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	ebx
$LN1@BufferSpac@3:

; 574  : 
; 575  : 	return  k;

	mov	DWORD PTR tv219[esp+8], esi
	fild	DWORD PTR tv219[esp+8]
	test	esi, esi
	jns	SHORT $LN9@BufferSpac@3
	fadd	QWORD PTR __real@41f0000000000000
$LN9@BufferSpac@3:
	mov	eax, DWORD PTR [edi+20]
	fild	DWORD PTR [edi+20]
	test	eax, eax
	jns	SHORT $LN10@BufferSpac@3
	fadd	QWORD PTR __real@41f0000000000000
$LN10@BufferSpac@3:

; 570  : 	
; 571  : 	if (a < 0) return a;
; 572  : 	
; 573  : 	k = ((double)a / (double)incoming->CQsize())*100;

	fdivp	ST(1), ST(0)
	pop	edi
	pop	esi
	pop	ebp
	fmul	QWORD PTR __real@4059000000000000

; 576  : }

	ret	8
_BufferSpaceAvailable_Percentage@8 ENDP
_TEXT	ENDS
PUBLIC	_BufferSpaceAvailable@8
; Function compile flags: /Ogtpy
;	COMDAT _BufferSpaceAvailable@8
_TEXT	SEGMENT
_buffer_nr$ = 8						; size = 4
_ReadChannel$ = 12					; size = 4
_BufferSpaceAvailable@8 PROC				; COMDAT

; 559  : {

	push	ebp

; 560  : 	Buffers * incoming = (Buffers*) buffer_nr;
; 561  : 	return incoming->QFree(ReadChannel);

	mov	ebp, DWORD PTR _ReadChannel$[esp]
	push	edi
	mov	edi, DWORD PTR _buffer_nr$[esp+4]
	cmp	ebp, DWORD PTR [edi+32]
	jb	SHORT $LN3@BufferSpac@4
	pop	edi
	xor	eax, eax
	pop	ebp

; 562  : }

	ret	8

; 560  : 	Buffers * incoming = (Buffers*) buffer_nr;
; 561  : 	return incoming->QFree(ReadChannel);

$LN3@BufferSpac@4:
	push	ebx
	push	esi
	lea	ebx, DWORD PTR [edi+44]
	push	ebx
	call	DWORD PTR __imp__EnterCriticalSection@4
	mov	esi, DWORD PTR [edi+20]
	sub	esi, DWORD PTR [edi+ebp*4+592]
	push	ebx
	call	DWORD PTR __imp__LeaveCriticalSection@4
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi
	pop	ebp

; 562  : }

	ret	8
_BufferSpaceAvailable@8 ENDP
_TEXT	ENDS
PUBLIC	_BufferFlush@8
; Function compile flags: /Ogtpy
;	COMDAT _BufferFlush@8
_TEXT	SEGMENT
_buffer_nr$ = 8						; size = 4
_ReadChannel$ = 12					; size = 4
_BufferFlush@8 PROC					; COMDAT

; 553  : 	Buffers * incoming = (Buffers*) buffer_nr;
; 554  : 	incoming->Flush(ReadChannel);

	mov	eax, DWORD PTR _ReadChannel$[esp-4]
	mov	ecx, DWORD PTR _buffer_nr$[esp-4]
	call	?Flush@Buffers@@QAEXH@Z			; Buffers::Flush

; 555  : 	return;
; 556  : }

	ret	8
_BufferFlush@8 ENDP
_TEXT	ENDS
PUBLIC	_BufferWrite@12
; Function compile flags: /Ogtpy
;	COMDAT _BufferWrite@12
_TEXT	SEGMENT
_buffer_nr$ = 8						; size = 4
_NrOfBytes$ = 12					; size = 4
_Data$ = 16						; size = 4
_BufferWrite@12 PROC					; COMDAT

; 547  : 	Buffers * incoming = (Buffers*) buffer_nr;
; 548  : 	return incoming->Write(NrOfBytes,Data);

	jmp	?Write@Buffers@@QAEHIPAE@Z		; Buffers::Write
_BufferWrite@12 ENDP
_TEXT	ENDS
PUBLIC	_BufferRead@16
; Function compile flags: /Ogtpy
;	COMDAT _BufferRead@16
_TEXT	SEGMENT
_buffer_nr$ = 8						; size = 4
_ReadChannel$ = 12					; size = 4
_NrOfBytes$ = 16					; size = 4
_Data$ = 20						; size = 4
_BufferRead@16 PROC					; COMDAT

; 541  : 	Buffers * incoming = (Buffers*) buffer_nr;
; 542  : 	return incoming->Read(ReadChannel, NrOfBytes,Data);

	jmp	?Read@Buffers@@QAEHIIPAE@Z		; Buffers::Read
_BufferRead@16 ENDP
PUBLIC	??0Buffers@@QAE@III@Z				; Buffers::Buffers
; Function compile flags: /Ogtpy
;	COMDAT ??0Buffers@@QAE@III@Z
_TEXT	SEGMENT
__BufferType$ = 8					; size = 4
??0Buffers@@QAE@III@Z PROC				; Buffers::Buffers, COMDAT
; _this$ = esi
; __NrPtrs$ = ecx
; __size$ = eax

; 83   : {

	push	ebx
	push	ebp
	push	edi

; 84   : 	this->size = _size;
; 85   : 	this->QueueError = false;
; 86   : 	this->CreateQueue(_size);

	push	eax
	xor	ebx, ebx
	push	esi
	mov	edi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7Buffers@@6B@
	mov	DWORD PTR [esi+20], eax
	mov	BYTE PTR [esi+16], bl
	call	?CreateQueue@Buffers@@AAEHI@Z		; Buffers::CreateQueue

; 87   : 	this->WrPtr = 0;
; 88   : 	this->BufferType = _BufferType;

	mov	eax, DWORD PTR __BufferType$[esp+8]

; 89   : 	this->NrPtrs = _NrPtrs;
; 90   : 	this->OverFlow = false;
; 91   : 
; 92   : 	memset(&this->RdPtr[0], 0, _NrPtrs*sizeof (unsigned int));

	lea	ebp, DWORD PTR [edi*4]
	push	ebp
	lea	ecx, DWORD PTR [esi+80]
	push	ebx
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], edi
	push	ecx
	mov	DWORD PTR [esi+40], ebx
	call	_memset

; 93   : 	memset(&this->QLoad[0], 0, _NrPtrs*sizeof (unsigned int));

	push	ebp
	lea	edx, DWORD PTR [esi+592]
	push	ebx
	push	edx
	call	_memset

; 94   : 
; 95   : 	//Calculate SSE2 counter
; 96   : 	this->Amount_SSE2_Operations = _NrPtrs + (4 - (_NrPtrs % 4));

	mov	eax, edi
	and	eax, 3
	sub	edi, eax
	add	edi, 4
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+36], edi

; 97   : 		
; 98   : 	if (CheckCPUFeature(2) == 1) this->SSE2_Present = true;

	cmp	BYTE PTR _CPU_Initialized, bl
	jne	SHORT $LN34@Buffers@2
	call	?GetCPUInfo@@YAXXZ			; GetCPUInfo
$LN34@Buffers@2:
	mov	eax, 1
	cmp	BYTE PTR _SSE2, bl
	jne	SHORT $LN67@Buffers@2
	cmp	BYTE PTR _SSE3, bl
	jne	SHORT $LN67@Buffers@2
	cmp	BYTE PTR _SSE41, bl
	jne	SHORT $LN67@Buffers@2
	cmp	BYTE PTR _SSE42, bl
	jne	SHORT $LN67@Buffers@2
	cmp	BYTE PTR _AVX, bl
	jne	SHORT $LN67@Buffers@2
	cmp	BYTE PTR _AES, bl
	jne	SHORT $LN67@Buffers@2
	cmp	BYTE PTR __64_BIT, bl
	jne	SHORT $LN67@Buffers@2
	cmp	BYTE PTR _SpeedStep, bl
	jne	SHORT $LN67@Buffers@2
	cmp	BYTE PTR _HyperThreading, bl
	jne	SHORT $LN67@Buffers@2
	cmp	DWORD PTR _AmountLogicalCPU, eax
	jne	SHORT $LN4@Buffers@2
$LN67@Buffers@2:
	mov	BYTE PTR [esi+72], al
	jmp	SHORT $LN3@Buffers@2
$LN4@Buffers@2:

; 99   : 	else this->SSE2_Present = false;

	mov	BYTE PTR [esi+72], bl
$LN3@Buffers@2:

; 100  : 
; 101  : 	if (CheckCPUFeature(11) > 2)

	cmp	BYTE PTR _CPU_Initialized, bl
	jne	SHORT $LN64@Buffers@2
	call	?GetCPUInfo@@YAXXZ			; GetCPUInfo
$LN64@Buffers@2:
	cmp	DWORD PTR _AmountLogicalCPU, 2
	jle	SHORT $LN2@Buffers@2

; 102  : 	{	 // Tripple Core & higher
; 103  : 		InitializeCriticalSectionAndSpinCount(&this->Crit1, 0x0000005F);	// 95 Spin is added (benchmarked using Vtune) so a thread does not use an expensive Sleep while the 

	push	95					; 0000005fH
	lea	ecx, DWORD PTR [esi+44]
	push	ecx

; 104  : 	}																// chance is high it will be able to continue within a few cycles
; 105  : 	else															// This improves the speed dramatically on very small Threaded Reads or Writes (<64 Bytes)
; 106  : 	{	// Single or Dual Core
; 107  : 		InitializeCriticalSectionAndSpinCount(&this->Crit1, 0x00000000);

	call	DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8
	pop	edi
	pop	ebp

; 108  : 	}
; 109  : }

	mov	eax, esi
	pop	ebx
	ret	4
$LN2@Buffers@2:

; 104  : 	}																// chance is high it will be able to continue within a few cycles
; 105  : 	else															// This improves the speed dramatically on very small Threaded Reads or Writes (<64 Bytes)
; 106  : 	{	// Single or Dual Core
; 107  : 		InitializeCriticalSectionAndSpinCount(&this->Crit1, 0x00000000);

	push	ebx
	lea	edx, DWORD PTR [esi+44]
	push	edx
	call	DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8
	pop	edi
	pop	ebp

; 108  : 	}
; 109  : }

	mov	eax, esi
	pop	ebx
	ret	4
??0Buffers@@QAE@III@Z ENDP				; Buffers::Buffers
_TEXT	ENDS
PUBLIC	_BufferCreate@16
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$_BufferCreate@16 DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_BufferCreate@16$2
	DD	0ffffffffH
	DD	00H
__catchsym$_BufferCreate@16$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_BufferCreate@16$0
__tryblocktable$_BufferCreate@16 DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$_BufferCreate@16$3
__ehfuncinfo$_BufferCreate@16 DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$_BufferCreate@16
	DD	01H
	DD	FLAT:__tryblocktable$_BufferCreate@16
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT _BufferCreate@16
_TEXT	SEGMENT
$T31181 = -24						; size = 4
$T31176 = -20						; size = 4
__$EHRec$ = -16						; size = 16
_size$ = 8						; size = 4
_NewBuffer$ = 12					; size = 4
_buffertype$ = 12					; size = 4
$T31173 = 16						; size = 4
_NrReadChannels$ = 16					; size = 4
_Status$ = 20						; size = 4
_BufferCreate@16 PROC					; COMDAT

; 496  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$_BufferCreate@16
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 497  : 	unsigned int i=0;
; 498  : 	*Status = 0;
; 499  : 	
; 500  : 	if (NrReadChannels > MAXPTRS) NrReadChannels = MAXPTRS;	// Check (and set) maximum allowed nr of Read Pointers

	mov	ebx, DWORD PTR _NrReadChannels$[ebp]
	mov	eax, DWORD PTR _Status$[ebp]
	mov	DWORD PTR [eax], 0
	cmp	ebx, 128				; 00000080H
	jbe	SHORT $LN8@BufferCrea
	mov	ebx, 128				; 00000080H
$LN7@BufferCrea:

; 502  : 
; 503  : 	if (size > 1048576*MAXSIZE) size = 1048576*MAXSIZE;	// Buffer Maximum Capacity

	mov	edi, DWORD PTR _size$[ebp]
	cmp	edi, 536870912				; 20000000H
	jbe	SHORT $LN6@BufferCrea
	mov	edi, 536870912				; 20000000H

; 504  : 	if (size < MINSIZE) size = MINSIZE;	// Buffer Minimum Capacity

	jmp	SHORT $LN5@BufferCrea
$LN8@BufferCrea:

; 501  : 	if (!NrReadChannels) {*Status = -1 ;return 0;}	// ReadChannels must be at least 1

	test	ebx, ebx
	jne	SHORT $LN7@BufferCrea
	mov	DWORD PTR [eax], -1
	xor	eax, eax

; 526  : 	
; 527  : 	i = (unsigned int) NewBuffer;
; 528  : 	return i;
; 529  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN6@BufferCrea:

; 504  : 	if (size < MINSIZE) size = MINSIZE;	// Buffer Minimum Capacity

	cmp	edi, 16					; 00000010H
	jae	SHORT $LN5@BufferCrea
	mov	edi, 16					; 00000010H
$LN5@BufferCrea:

; 505  : 
; 506  : 	if (buffertype > 1) {*Status = -2 ;return 0;}	// Unknown Buffertype

	cmp	DWORD PTR _buffertype$[ebp], 1
	jbe	SHORT $LN4@BufferCrea
	mov	DWORD PTR [eax], -2			; fffffffeH
	xor	eax, eax

; 526  : 	
; 527  : 	i = (unsigned int) NewBuffer;
; 528  : 	return i;
; 529  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN4@BufferCrea:

; 507  : 	
; 508  : 	Buffers * NewBuffer;
; 509  : 
; 510  : 	try
; 511  : 	{
; 512  : 		NewBuffer = new Buffers(NrReadChannels, size, buffertype);

	push	1104					; 00000450H
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	DWORD PTR __imp_??2@YAPAXI@Z
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T31173[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	test	esi, esi
	je	SHORT $LN11@BufferCrea
	mov	eax, DWORD PTR _buffertype$[ebp]
	push	eax
	mov	eax, edi
	mov	ecx, ebx
	call	??0Buffers@@QAE@III@Z			; Buffers::Buffers
	mov	ecx, eax
	jmp	SHORT $LN12@BufferCrea
$LN11@BufferCrea:
	xor	ecx, ecx
$LN12@BufferCrea:
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	eax, ecx

; 513  : 		if (!NewBuffer) throw -1;

	test	ecx, ecx
	jne	SHORT $LN2@BufferCrea
	push	OFFSET __TI1H
	lea	ecx, DWORD PTR $T31176[ebp]
	push	ecx
	mov	DWORD PTR $T31176[ebp], -1
	call	__CxxThrowException@8
$LN24@BufferCrea:
$LN2@BufferCrea:

; 514  : 
; 515  : 		if (NewBuffer->QueueError)

	cmp	BYTE PTR [ecx+16], 0
	je	SHORT $LN9@BufferCrea

; 516  : 			{
; 517  : 				delete NewBuffer;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	1
	call	eax

; 518  : 				throw -1;

	push	OFFSET __TI1H
	lea	ecx, DWORD PTR $T31181[ebp]
	push	ecx
	mov	DWORD PTR $T31181[ebp], -1
	call	__CxxThrowException@8
$LN25@BufferCrea:
__catch$_BufferCreate@16$0:

; 519  : 			}
; 520  : 	}
; 521  : 	catch (...)
; 522  : 	{
; 523  : 		NewBuffer = nullptr;
; 524  : 		*Status = -3;	// Out of memory

	mov	edx, DWORD PTR _Status$[ebp]
	mov	DWORD PTR _NewBuffer$[ebp], 0
	mov	DWORD PTR [edx], -3			; fffffffdH

; 525  : 	}

	mov	eax, $LN21@BufferCrea
	ret	0
$LN21@BufferCrea:
	mov	eax, DWORD PTR _NewBuffer$[ebp]
$LN9@BufferCrea:

; 526  : 	
; 527  : 	i = (unsigned int) NewBuffer;
; 528  : 	return i;
; 529  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN23@BufferCrea:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_BufferCreate@16$2:
	mov	eax, DWORD PTR $T31173[ebp]
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx
	ret	0
__ehhandler$_BufferCreate@16:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$_BufferCreate@16
	jmp	___CxxFrameHandler3
text$x	ENDS
_BufferCreate@16 ENDP
END
